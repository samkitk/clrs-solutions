<!doctype html>
        <html lang="en">
        <head>
          <meta charset="utf-8">
          <title>Chapter 26.4</title>
          <link rel="stylesheet" href="../style.css">
          
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script>
    window.onload=function(){
      setTimeout(function(){
        if(screen.width<680){
          var wrapper=document.getElementById('wrapper');
          var zoom=screen.width/680;
          wrapper.style.zoom = zoom;
          document.body.style.width=screen.width+'px';
        }
      });
    };
  </script>

        </head>
        <body>
            <div id="wrapper">
                
        <div class="problem">
            <div class="problem-title" id="problem-1E">
                <a href="#problem-1E">1E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p>INITIALISAE-PREFLOW procedure creates the initial pre-flow in
the flow network.</p>
<p>It fills to capacity each edge that is leaving the source
<i>s</i> and all other edges are initialized with no flow.</p>
<p>It also initializes the height of <i>s t</i>o <img src=
"../imgs/db4dc8600b0b80041cb8b7085106e6b144d75626.png">and all
other nodes to 0.</p>
<p>It is further used in GENERIC-PUSH-RELABEL algorithm.</p>
<p>Referring to the procedure INITIALISE-PREFLOW (<i>G,s</i>) on
page number 740,</p>
<p>To calculate the value of <i>s</i>.<i>e</i> (Here
<i>s</i>=source and <i>e</i>=excess flow that is <i>s.e</i> donates
access flow to source) after the procedure INITIALISE-PREFLOW
(<i>G</i>,<i>s</i>) terminates</p>
<p>Initially, <i>s.e</i>=0</p>
<p>So,</p>
<p><img src=
"../imgs/0064753ec78e36f2c0345f7bee5a45707dd64908.png">is nothing
but</p>
<p><img src=
"../imgs/b0e706d8df36c1969cf1885c3e33bb466282eb06.png"></p>
<p>Here <img src=
"../imgs/befe320b4a18d5c716369d7c49c2a8a17b642869.png">=capacity of
edge from <i>s</i> to <img src=
"../imgs/16fce28c17f7df389e0e18b6b9ba53b68a6ac94a.png"></p>
<p>So its summation is total of capacity of edges from source to
its adjacent vertices. That is if no flow limitation is there in
term of capacity on in-between nodes, this summation will be equal
to the maximum flow for <i>G</i> (if no restriction then the flow
which is sent from source is same as that of the sink).Since in
real situations there are flow limitations on in-between nodes so
the above summation will always be less than or equal to the
maximum flow for <i>G</i>.</p>
<p>So, <img src=
"../imgs/510802a3394310f2dd497ea80a0be41e3442545d.png"></p>
<p>Where, <img src=
"../imgs/1149ab19ff3687745ac32453ac4dae7cb91f9710.png"> is a
maximum flow for <i>G</i>.</p>
<p><b>Hence, proved</b></p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-2E">
                <a href="#problem-2E">2E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<img src="../imgs/6f3cef606f4ddeac53de647c58ff0d1a6f085d5b.png">
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-3E">
                <a href="#problem-3E">3E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<img src="../imgs/b3c7767a3ef173126c6e7b7b40f7eb7e7466c784.png">
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-4E">
                <a href="#problem-4E">4E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p><b>A fast algorithm to find a minimum cut in</b>
<i><b>G</b></i></p>
<p>According to the maximum flow minimum cut theorem:</p>
<p><img src=
"../imgs/4baaf9eb65141ace480ce79749c5dd3a1691f6ef.png"></p>
<p>The maximum flow has the value equal to the minimum cut.</p>
</div>
<hr>
<div class="answer">
<p>Now given the maximum flow, value of maximum flow can be
determined by following algorithm-</p>
<p><i>list</i> <i>E</i></p>
<p><i>max_flow</i> = given</p>
<p><img src="../imgs/78d50dd9c980592efe773729ff24f3d4188734bf.png">
= |<i>G.V</i>| - 2</p>
<p>while (<img src=
"../imgs/4b6e1bef1f71e19a799e5cecbf45aea67ed2c942.png"><img src=
"../imgs/2bb7da9de01dad3615963d2d165dae9a0cff53a1.png"><img src=
"../imgs/78d50dd9c980592efe773729ff24f3d4188734bf.png">)</p>
<p><i>partition</i> the set of vertices in <i>S</i> and <i>V</i> -
<i>S</i></p>
<p><i>capacity</i> = check for the value of maximum flow</p>
<p>if (<i>max_flow</i> = <i>capacity</i> )</p>
<p><i>save</i> the vertex set to <i>E</i></p>
<p>else</p>
<p><i>add</i> <img src=
"../imgs/278514138a850339814ad2b02efcb3704d3db469.png"> to vertex
set <i>S</i> and remove it from vertex set <i>V</i> - <i>S</i></p>
<p><img src=
"../imgs/4b6e1bef1f71e19a799e5cecbf45aea67ed2c942.png">++</p>
<p>return <i>E</i></p>
<p>end</p>
<p>The algorithm checks for the possible vertex sets the value of
capacity of cut with the given value of maximum flow and then
returns the partition set.</p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-5E">
                <a href="#problem-5E">5E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<img src="../imgs/92d8aaa92c42884871c1b353474ae7576c7c0e3b.png">
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-6E">
                <a href="#problem-6E">6E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p>The algorithm uses the saturation of an edge to stop from
pushing the weight from one vertex to another.</p>
<p><b>Saturation</b> refers to the condition when the flow over an
edge becomes equal to its capacity.</p>
</div>
<hr>
<div class="answer">
<p>It is given that the given graph has V vertices and E edges and
the capacities of the edge are in the set {1, 2, …, k}.</p>
<p>The information required to analyze the algorithm is as
follows:</p>
<p>• The algorithm visits each vertex to perform the push-relabel
operation.</p>
<p>• Each edge with capacity k can have at max k-1 non- saturating
push before performing a push operation which makes it saturated,
that is at most k push operations can be applied on an edge.</p>
</div>
<hr>
<div class="answer">
<p>The analysis of the given algorithm is as follows:</p>
<p>• The time it takes to visit a vertex is O(1).</p>
<p>Therefore, the time it takes to visit V vertices is O(V).</p>
<p>• The time it takes to visit an edge is O(1).</p>
<p>Therefore, the time to take to visit E edges is O(E).</p>
<p>• The time it takes perform a push operation is O(1).</p>
<p>An edge with capacity k can perform up to k push operations.</p>
<p>Therefore, an edge with capacity k takes O(k) time to perform
the push operations.</p>
<p>• Since there are E edges in the graph therefore, the total time
to perform the push operations is O(kE).</p>
<p>The total running time of the algorithm is the addition of all
the operations in the algorithm.</p>
<p>The running time of the algorithm is therefore as follows:</p>
<p><img src=
"../imgs/d2584f1f82f9b0dbbd87a3a0b65f08f2de7705ae.png"></p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-7E">
                <a href="#problem-7E">7E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p>Consider the algorithm INITIALIZE-PREFLOW on page 740.</p>
<p>If we set <img src=
"../imgs/95289761e123e226171dee1cecf457f66b6255a3.png">, we have to
change our definition of a height function to allow<img src=
"../imgs/626fdf362e8712651acd267d6f163cd20801f155.png"> , rather
than <img src=
"../imgs/94afa641262f15a26369847adc8f71082887f9e0.png">.</p>
<p>The only change we need to make to the proof of correctness is
to update the proof of Lemma.</p>
<p>The original proof derives the contradiction that <img src=
"../imgs/0546afedd4bed1098a85e41288b305db92e3fa36.png">, which is
at odds with <img src=
"../imgs/94afa641262f15a26369847adc8f71082887f9e0.png">.</p>
<p>When <img src=
"../imgs/626fdf362e8712651acd267d6f163cd20801f155.png">, there is
no contradiction.</p>
</div>
<hr>
<div class="answer">
<p>As in original proof, assume that there is a simple augmenting
path <img src=
"../imgs/db8c2da3d4de888d292f617422ced7eb0d59b1cd.png"> where
<img src="../imgs/22c71060db63004e1cb10e008c672fc78ce194b1.png">and
<img src=
"../imgs/85c7f59bc0d7c9096cb6bdc9b96076e7a9548112.png">where
<i>s</i> represents the source and <i>t</i> represents the
sink.</p>
<p>So, that <img src=
"../imgs/663e8256e8edec7ef289ef315c375389dba0d0eb.png">.</p>
<p>It had been saturated in Initialize-Pre-flow, which means that
we had to push some flow from <img src=
"../imgs/52a289e96985ecf8559154a939fcec8b1a56a1b8.png"> to<img src=
"../imgs/ba795886e97dcbb50fcba9d094b08e6f186373f8.png">.</p>
<p>For that to happened, we must have <img src=
"../imgs/62b8d230bdfd68a3581ba4d8c87094e7d8012704.png"> .</p>
<p>If we set <img src=
"../imgs/95289761e123e226171dee1cecf457f66b6255a3.png">, that means
<img src="../imgs/14d751b160790a07e1a541dc58ff0f7e86cbfd23.png">
was <img src=
"../imgs/da4c73314fed0638132111107b71acad2c06aecc.png"> at the
time. Since then, <img src=
"../imgs/14d751b160790a07e1a541dc58ff0f7e86cbfd23.png"> did not
decrease, and therefore, we have the following:</p>
<p><img src="../imgs/8120e170376e8ebdba93807aeb0f43385269ab33.png">
…… (1)</p>
<p>Working backwards over our augmenting path, we have the
following:</p>
<p><img src="../imgs/eb7293afe6ce439c925dbaf8049aae2fceea20a2.png">
<img src="../imgs/e914cec7fc70b0f3a02c38906314acf57aba7e9e.png">
for <img src=
"../imgs/ab8d30928f42ce9f541d35ae2fd7a322f7909fc4.png"> = 0,
1......<img src=
"../imgs/85b7abaaaaa69d53adcbb3d4db38cc4616bb90e3.png">.</p>
<p>So, for <img src=
"../imgs/52a289e96985ecf8559154a939fcec8b1a56a1b8.png">,<img src=
"../imgs/16b0b1d8e437dc69c2bcc4fa893ff41b34b8043c.png"> where
<img src=
"../imgs/014a15ee0ea8d23d181ad03d4e35e0e1d1e01d98.png">(height of
sink is always considered to be zero).</p>
</div>
<hr>
<div class="answer">
<p>As before, because the augmenting path is simple, <img src=
"../imgs/663e8256e8edec7ef289ef315c375389dba0d0eb.png">.</p>
<p>So,</p>
<p><img src="../imgs/dc6e31ee6aa59be0c07db5b0b3af3585bc336bc3.png">
…… (2)</p>
<p>Comparing equation (1) and (2).</p>
<p>Since (2) contradicts (1) the above assumption was wrong.</p>
<p>So, lemma 26.17 on page 742 is still true.</p>
<p>Thus, if the line 6 of INITIALISE-PREFLOW changes to<img src=
"../imgs/b6e0f0e57b89fa130e8a6931e2babdace40c56f5.png"> then, it
would not affect the correctness or asymptotic performance of the
generic push-relabel algorithm.</p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-8E">
                <a href="#problem-8E">8E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p>Consider the GENERIC-PUSH-RELABEL procedure,</p>
<p><img src="../imgs/f4f14b6aea8034f1e21c538177dc7d415eb879f2.png">
Is the distance from u to v in the residual network<img src=
"../imgs/753848f6edf7af2526237b01a186952baf7755c5.png">.</p>
<p>Distance are nothing but, number of edges between the
vertices.</p>
<p><b>Case 1:</b></p>
<p>When <img src=
"../imgs/f6c60861ea1c911a1ff2803d8d66e0a1aff6f989.png"></p>
<p>Let there is a simple path <i>p</i> from <i>u</i> to <i>t</i>
in<img src=
"../imgs/753848f6edf7af2526237b01a186952baf7755c5.png">.</p>
<p>Let path p be <img src=
"../imgs/01e2c50f62becb7cfec5eec807342ec014cda0d1.png"></p>
<p>Here,<img src=
"../imgs/7b79dd9d2e30abb122e0cfffd10cd9c1030f1509.png">and
<img src="../imgs/8013491e402fc131482caff30388b1d84d884978.png">=t</p>
<p>Here <img src=
"../imgs/a51ea6ebec95397ff9e3649b11c14a81e58af910.png"></p>
<p>And</p>
<p><img src=
"../imgs/3c6260529a7163ee17c617aa599924a17c094845.png"></p>
<p><img src=
"../imgs/9a2485d8126c269cd943037dcab7251a49e0105a.png"></p>
<p><img src=
"../imgs/a8520a3637b352ca8ed9134413a4f0bae7aa0a9b.png"></p>
<p><img src=
"../imgs/a587cf7629437ca659c7b5a165e2fab0d99927ef.png"></p>
<p><img src=
"../imgs/78da95109573294f9a67ac4a87ee11da4fe02ac9.png"></p>
<p>Adding above we will get</p>
<p><img src="../imgs/28ca6a5bd4a92b497fb4e41db26a65f20c2c3e13.png">
<img src="../imgs/2bb7da9de01dad3615963d2d165dae9a0cff53a1.png">
<img src=
"../imgs/9991206bbea0922a332ccb514baee24234ef980c.png">+<i>k</i></p>
<p>Here <img src=
"../imgs/9991206bbea0922a332ccb514baee24234ef980c.png">=0 because
<img src="../imgs/5f183b6af67493f5add0e88367ba2c5b95a47c65.png">is
sink.</p>
<p><img src="../imgs/28ca6a5bd4a92b497fb4e41db26a65f20c2c3e13.png">
<img src=
"../imgs/2bb7da9de01dad3615963d2d165dae9a0cff53a1.png"><i>k</i></p>
<p><img src=
"../imgs/c04228580992dfed16ed8a0198081d399ae687ec.png">is <i>k</i>
in this case(since there are k edges in the path)</p>
<p>So <img src=
"../imgs/28ca6a5bd4a92b497fb4e41db26a65f20c2c3e13.png"> <img src=
"../imgs/2bb7da9de01dad3615963d2d165dae9a0cff53a1.png"><img src=
"../imgs/c04228580992dfed16ed8a0198081d399ae687ec.png"></p>
<b>Hence, proved</b></div>
<hr>
<div class="answer">
<p><b>Case 2:</b></p>
<p>When <img src=
"../imgs/34f38b4394074443fca7e0a13b1610e90ed97dae.png"></p>
<p>Let there is a simple path <i>p</i> from <i>u</i> to in<img src=
"../imgs/753848f6edf7af2526237b01a186952baf7755c5.png">.</p>
<p>Let path p be <img src=
"../imgs/01e2c50f62becb7cfec5eec807342ec014cda0d1.png"></p>
<p>Here,<img src=
"../imgs/7b79dd9d2e30abb122e0cfffd10cd9c1030f1509.png">and
<img src="../imgs/8013491e402fc131482caff30388b1d84d884978.png">=<i>s</i></p>
<p>Here <img src=
"../imgs/a51ea6ebec95397ff9e3649b11c14a81e58af910.png"></p>
<p>And</p>
<p><img src=
"../imgs/3c6260529a7163ee17c617aa599924a17c094845.png"></p>
<p><img src=
"../imgs/9a2485d8126c269cd943037dcab7251a49e0105a.png"></p>
<p><img src=
"../imgs/a8520a3637b352ca8ed9134413a4f0bae7aa0a9b.png"></p>
<p><img src=
"../imgs/a587cf7629437ca659c7b5a165e2fab0d99927ef.png"></p>
<p><img src=
"../imgs/78da95109573294f9a67ac4a87ee11da4fe02ac9.png"></p>
<p>Adding above we will get</p>
<p><img src="../imgs/28ca6a5bd4a92b497fb4e41db26a65f20c2c3e13.png">
<img src="../imgs/2bb7da9de01dad3615963d2d165dae9a0cff53a1.png">
<img src=
"../imgs/9991206bbea0922a332ccb514baee24234ef980c.png">+<i>k</i></p>
<p>Here <img src=
"../imgs/9991206bbea0922a332ccb514baee24234ef980c.png">= <img src=
"../imgs/db4dc8600b0b80041cb8b7085106e6b144d75626.png"> because
<img src="../imgs/5f183b6af67493f5add0e88367ba2c5b95a47c65.png">is
source.</p>
<p><img src="../imgs/28ca6a5bd4a92b497fb4e41db26a65f20c2c3e13.png">
<img src="../imgs/2bb7da9de01dad3615963d2d165dae9a0cff53a1.png">
<img src=
"../imgs/db4dc8600b0b80041cb8b7085106e6b144d75626.png">+<i>k</i></p>
<p><img src=
"../imgs/b881a25f6d42579d3026b894645a7fe338d07c8e.png">is k in this
case (since there are k edges in the path)</p>
<p><img src="../imgs/28ca6a5bd4a92b497fb4e41db26a65f20c2c3e13.png">
<img src="../imgs/2bb7da9de01dad3615963d2d165dae9a0cff53a1.png">
<img src="../imgs/db4dc8600b0b80041cb8b7085106e6b144d75626.png">+
<img src=
"../imgs/b881a25f6d42579d3026b894645a7fe338d07c8e.png"></p>
<p>That is</p>
<p><img src="../imgs/28ca6a5bd4a92b497fb4e41db26a65f20c2c3e13.png">
-<img src=
"../imgs/db4dc8600b0b80041cb8b7085106e6b144d75626.png"><img src=
"../imgs/2bb7da9de01dad3615963d2d165dae9a0cff53a1.png"> <img src=
"../imgs/b881a25f6d42579d3026b894645a7fe338d07c8e.png"></p>
<p><b>Hence, proved</b></p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-9E">
                <a href="#problem-9E">9E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p><b>Flow Network</b></p>
<p>A flow network, in the most basic form, is a directed graph.
Each of the edges has a capacity assigned to it. In the network a
certain amount of flow goes from each edge of the network. There
are certain nodes in the graph fromwhich the flowstarts and to
which the flow ends. These two nodes are calledthe origin and
destination ofthe network respectively.</p>
<p>In the diagram below the node <i>s</i> is the origin of the
network and the node <i>t</i> is the destination or sink of the
network. Each of the graph edge has a capacity. The capacity
defines the data value that can go through that edge. The capacity
is always a positive integer. One more thing is that if there
exists an edge from a vertex <i>v</i><sub>1</sub> to vertex
<i>v</i><sub>2</sub> than there can be no edge from
<i>v</i><sub>2</sub> to <i>v</i><sub>1</sub>.</p>
<p><img src="../imgs/f7c99af66cca771168fbcf08c94e0e92a3e3e366.png"
alt="C:\Users\evelyn 16\Desktop\CDR TIP\11.tif"></p>
<p>In the above diagram vertex <i>s</i> is the source and the
vertex <i>t</i> is the sink or destination. The capacity of each
edge is shown alongside the edge. As the edge from <i>s</i> to
<i>v</i><sub>1</sub> has the capacity of 16.</p>
<p>A flow network has various applications in practicality. It is
used in data warehouses, scientific research and electricity
distribution etc.</p>
</div>
<hr>
<div class="answer">
<p><b>Generic push relabel algorithm:</b></p>
<p>The generic push relabel algorithm is used for computing maximum
flow from origin to destination in a network. The distance of the
source vertex that is the vertex from where the flow is started is
fixed at <img src=
"../imgs/0969cb112621fda649bb6227c14e287692b44a17.png"> and the
height of sink vertex is fixed at value 0.</p>
<p>The height of all the other vertices through which the flow is
passed to sink is initially set to 0 which increases with time.</p>
<p>The algorithm uses the method INITIALIZE-PREFLOW in which the
height and the excess flow for each vertex is set. It also
initializes the flow for each edge in the network and the quantity
of the flow for the edges adjacent to the source vertex is set.</p>
<p>The flow for the edges going from the source vertex is set to
its maximum value that is equal to the capacity of the edge.</p>
<p>It has two major operations involved in it, <b>PUSH</b> and
<b>RELABEL</b>.</p>
</div>
<hr>
<div class="answer">
<p><b>PUSH</b> <b><img src=
"../imgs/f321eef7c244c834706dd4512bd5f8cb7a83f826.png"></b> :</p>
<p>In the push operation the excess flow is pushed from one vertex
to the other vertex. It is pushed from a vertex at higher level to
a vertex at the lower level.</p>
<p>It may be possible that the flow in an edge from the lower level
vertex to the higher level vertex is positive but the push
operation will not support this type of flow. The conditions and
the action that are performed in the push operation are as:</p>
<p><b>Precondition:</b></p>
<p>To perform a push operation two conditions must be
fulfilled:</p>
<p>1. Thevertex<i>u</i>is active or overflowing that is excess
flow<img src=
"../imgs/8ed931ae0f335b353bdd4d5cd13ed8c2f776352d.png">and the
residual capacity<img src=
"../imgs/7bed25aeb1a75b283eeeaa9797f787eee92fc54a.png">.</p>
<p>2. The height of vertex <i>u</i> must be larger than the
distance of vertex <i>v</i> that is<img src=
"../imgs/f7dfd2ae9034f65372289265c7cee975368bf6bf.png"></p>
<p><b>Action:</b></p>
<p>Push<img src=
"../imgs/17077cb6d8cd91115ceddb80187c38f3bc09e8d5.png">from vertex
<i>u</i> to vertex <i>v</i>.</p>
</div>
<hr>
<div class="answer">
<p><b>Labeling:</b></p>
<p>A labeling is said to be valid only when a function <img src=
"../imgs/f42faa495a84c51e4735d142a7151a075de2051d.png"> from
vertices to non-negative integers.</p>
<p><b>RELABEL</b> <img src=
"../imgs/d73fe653c18d43ef269e7a744d31220c1f4a1e65.png">:</p>
<p>The algorithm considers that the flow can be pushed only to the
vertex, which is downhill from the sender vertex.</p>
<p>So, for any vertex <i>u</i> if there existan edge to the any
vertex which is not saturated yet and they both are at the same
level or at the same height then the height of the vertex is
increased by one. That is the vertex <i>u</i> is relabeled and in
the relabel operation the height of vertex <i>u</i> is updated
as:</p>
<p><b>Precondition:</b></p>
<p>To perform a relabel operation two conditions must be
fulfilled:</p>
<p>1. The vertex <i>u</i>is the active overflowing vertex that
is<img src=
"../imgs/5e4bbbb8ad82241b4f115b7fbbabe88dfd044578.png"></p>
<p>2. For all the vertices <i>v</i> in the residual network for
which there is an edge from vertex <i>u</i> to vertex <i>v</i>
necessarily<img src=
"../imgs/4dc046c4dcf785cd77adf2163e90195a8441ba2e.png">.</p>
<b>Action:</b> Relabel the vertex <i>u</i> by increasing its height
as: <img src=
"../imgs/2a263977796d18cd26d18346584c0bc83eed73c8.png">.</div>
<hr>
<div class="answer">
<p><b>GENERIC PUSH AND RELABEL ALGORITHM:-</b></p>
<p><i>h</i>= labeling</p>
<p><i>p</i>=path</p>
<p>// initialize the labeling</p>
<p>1. <img src=
"../imgs/fc5d57ad0e4ba5e12ad94f1c479983e7e5a505a7.png">and<img src=
"../imgs/0a4be25469d60d7b9044a3877854c43000e2fca6.png"><b>for</b>
all <img src=
"../imgs/68055f3f51921472e9edee5caab4934d3f6801da.png"></p>
<p>// initialize pre flow with its respective capacity</p>
<p>2. <img src=
"../imgs/ff61965e7b811162bd3def86ead84396b789fd90.png"><b>for</b><img src="../imgs/5e4f7e9d42bb6fe38d44c7aec18dc24a3daea8d1.png">and
<img src=
"../imgs/3df0822910d034d5087e9b2ffe0d8027d0b7b6b7.png"><b>for</b>
all other edges</p>
<p>3. <b>while</b><img src=
"../imgs/9f09b54421b7ff0d34a36913040c3aba6568ce38.png"> with
<img src=
"../imgs/7ee846d249fa3c8e3363e9ea4acc2224ad7346d8.png"><b>do</b></p>
<p>4. <b>if</b><img src=
"../imgs/ac2ef06b72cb4fe35e78eb4cd94614879f04269e.png"> residual
edge in <img src=
"../imgs/e572ceca88715458f5aa87f6e24154492a84c733.png"> and
<img src=
"../imgs/8b708126a777722126bd1d5f2360082e3b5cc1bf.png"><b>then</b></p>
<p>// comparing the label in given graph</p>
<p>5. <b>if</b><img src=
"../imgs/f321eef7c244c834706dd4512bd5f8cb7a83f826.png"> is forward
<b>then</b></p>
<p>// push it forward</p>
<p>6. increase<img src=
"../imgs/25e1fecf8a0c7acc7f9615a2a293b5dbf927f3bf.png">by min
<img src=
"../imgs/64bfb1373a90b53ca2d9bb72d7f4fb7f3751b2ab.png"></p>
<p>7. <b>if</b><img src=
"../imgs/f321eef7c244c834706dd4512bd5f8cb7a83f826.png"> is backward
<b>then</b></p>
<p>// push it backward</p>
<p>8. decrease<img src=
"../imgs/25e1fecf8a0c7acc7f9615a2a293b5dbf927f3bf.png"> by min
<img src=
"../imgs/7c6858a30f4c44c924124ec4aeb814a4288ecb91.png"></p>
<p>// relabeled node</p>
<p>9. <b>else</b> <img src=
"../imgs/4198dd3d63202cbe9cb6869348bf7b93ff934ef1.png"></p>
<p>10. <b>return</b> <i>f</i></p>
</div>
<hr>
<div class="answer">The above algorithm is the modified version of
push-relabel algorithm. Modified parts according to the question
are in line 5 and line 7, and there out gives according to the
modification.</div>
<hr>
<div class="answer">
<p><b>Diagramatical Representation GENERIC PUSH AND RELABEL
ALGORITHMoperations:</b></p>
<p>1. In the flow network the initial preflow labeling is shown.
The height or the label of the node represented inside the box node
and the capacity of each edge is onto the edge.</p>
<p><img src="../imgs/bb0b06f4354e12f534e83f41f7290ac1c0e9bdd7.png"
alt="C:\Users\evelyn 16\Desktop\CDR TIP\1.tif"></p>
<p>2. An active vertex is selected which is connected with the
source vertex and the flow of this edge is as much as its capacity.
Change the label of selected vertex from 0 to 1.</p>
<p><img src="../imgs/ca9edca63ff55933acc12e783b4d05e9a74d763a.png"
alt="C:\Users\evelyn 16\Desktop\CDR TIP\2.tif"></p>
<p>3. The excess from the selected active vertex<img src=
"../imgs/d652a1e29926c5cd1d68942672a5276417cdb8f4.png">is pushed to
the vertex<img src=
"../imgs/b466d402aed63504ee39c4d8623924feccbdfff8.png">.</p>
<p><img src="../imgs/33f696428db4daa2baed24070a518f4f4bd78326.png"
alt="C:\Users\evelyn 16\Desktop\CDR TIP\3.tif"></p>
<p>4. Now the vertex <img src=
"../imgs/b466d402aed63504ee39c4d8623924feccbdfff8.png">is selected
and relabeled to 1 as shown in the graph.</p>
<p><img src="../imgs/7a62ab66929041e58c813a5f4fd427bacbc9457d.png"
alt="C:\Users\evelyn 16\Desktop\CDR TIP\4.tif"></p>
<p>5. The exces from the vertex <img src=
"../imgs/b466d402aed63504ee39c4d8623924feccbdfff8.png">is pushed to
the sink.</p>
<p><img src="../imgs/1f1462ea3c4f0c20d11008f01c909b7d394978cd.png"
alt="C:\Users\evelyn 16\Desktop\CDR TIP\5.tif"></p>
<p>6. Again the vertex <img src=
"../imgs/d652a1e29926c5cd1d68942672a5276417cdb8f4.png">is selected
and relabled to 5.</p>
<p><img src="../imgs/389a68ebe562d8ae264617ceeb1c4682078a4b1e.png"
alt="C:\Users\evelyn 16\Desktop\CDR TIP\6.tif"></p>
<p>7. As the maximum capacity of edge <img src=
"../imgs/a74f991d31c1fd397d8e84add887a5d19eb35be3.png">is 1 so no
more flow can be passed to the sink and so the excess flow from the
vertex <img src=
"../imgs/d652a1e29926c5cd1d68942672a5276417cdb8f4.png">is pushed
back to the source vertex.</p>
<p><img src="../imgs/5799142013948c8ffedce8a6c4161691af2e9fde.png"
alt="C:\Users\evelyn 16\Desktop\CDR TIP\7.tif"></p>
<p>8. The maximum flow that can be passed from source vertex to the
sink vertex is 1 so the maximum flow of this flow network is 1.</p>
<p><img src="../imgs/c635d627cf420b983b8034bd991c21317a9accb1.png"
alt="C:\Users\evelyn 16\Desktop\CDR TIP\8.tif"></p>
</div>
<hr>
<div class="answer">
<p><b>Analysis of algorithm:</b></p>
<p>In the above modified generic push relabel algorithm in each of
its particular iteration a push or a relabel operation is
performed. The total of the whole relabeling operations done is
less than<img src=
"../imgs/a997db3aa45c10ae3be7e2348130f64962f04ff2.png">.</p>
<p>The number of non saturating push activities completed is at
maximum of<img src=
"../imgs/a997db3aa45c10ae3be7e2348130f64962f04ff2.png"> and the
total number of saturating push operations (generic case) completed
is largest of<img src=
"../imgs/7a3fe42a349fdeeac7c921c3a747dacee919ed47.png">.</p>
<p>The maximum range of variation in the algorithm is <img src=
"../imgs/afaa625cdc7718d020865793b92653a744819692.png">because in
residual network flow depend upon edges and edges depend upon
vertices that are used to form that edges.</p>
<p><b>Hence, summing up all together the time complexity of above
algorithm is</b> <b><img src=
"../imgs/6614f0feab1f8dee04a088cd564de540df565590.png"></b></p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-10E">
                <a href="#problem-10E">10E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p>The maximum height that a vertex can have is as follows:</p>
<p><img src=
"../imgs/98c377d07899bb5aafc78f39d033dd54cbfd383b.png"></p>
<p>Since, the heights do not decrease, the number of vertices that
are overflowing are as follow:</p>
<p><img src=
"../imgs/c3f45ecfab5d21487dae4d1cbc1bf40fa5652411.png"></p>
<p><b>Therefore, over all the vertices, the contribution of
relabels to</b> <b><img src=
"../imgs/11ab01d15145531eb1990f9193ec3c3766e3e5fc.png"></b>
<b>would be at-most as follows:</b></p>
<p><img src=
"../imgs/1e6102c9d8b50656cff6225d84bb83e9b9545dee.png"></p>
</div>
<hr>
<div class="answer">
<p>A push which is under saturation, from the vertex u to v
increase <img src=
"../imgs/11ab01d15145531eb1990f9193ec3c3766e3e5fc.png"> by at-most
as follows:</p>
<p><img src=
"../imgs/9ba58b1b9a4f604f67245d00fa39e5c25dd7050c.png"></p>
<p>And the maximum count of pushes under the category of saturation
is as follows:</p>
<p><img src=
"../imgs/8c5d8ce400dc965dd0c2eeeba5e96f253c94f98c.png"></p>
<p><b>Therefore, the total contribution over all the pushes under
the category of saturation to</b> <b><img src=
"../imgs/11ab01d15145531eb1990f9193ec3c3766e3e5fc.png"></b> <b>is
max-to-max as follows:</b></p>
<p><img src=
"../imgs/f645282159d9757c725c188f42d9381b4bb13ece.png"></p>
<p>Since, the pushes under the category of non-saturation decrease
<img src="../imgs/11ab01d15145531eb1990f9193ec3c3766e3e5fc.png">by
at least on and <img src=
"../imgs/11ab01d15145531eb1990f9193ec3c3766e3e5fc.png">must be 0 as
per the termination.</p>
<p><b>Therefore, the maximum number of pushes under the category of
non-saturation is as follows:</b></p>
<p><img src=
"../imgs/945888a919074d7485c9879ac69bb7f68cd4e348.png"></p>
</div>
<hr>
<div class="answer">
<p>Hence, by using the above facts which are as follows:</p>
<p><img src=
"../imgs/9621ca666bf79164bdffdfb526690ede5ff81547.png"></p>
<p><b>The count of saturating pushes can be bonded to</b>
<b><img src=
"../imgs/1502b59c77f85224dc16a218a87ed4296d9cab05.png"></b>
<b>.</b></p>
</div>
</body>
</html>

            </div>     
        </div> 
        
            </div>    
            <div class="info">
                Chegg Rip, Introduction to Algorithms, 3rd Edition. [RipVer 0.1]
            <a href="../index.html">
                (index)
            </a>
            </div>
            <a class="return-float-btn" href="../index.html">
                <span class="arrow-left icon"/>    
            </a>
        </body>
        </html>
        