<!doctype html>
        <html lang="en">
        <head>
          <meta charset="utf-8">
          <title>Chapter 12.2</title>
          <link rel="stylesheet" href="../style.css">
          
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script>
    window.onload=function(){
      setTimeout(function(){
        if(screen.width<680){
          var wrapper=document.getElementById('wrapper');
          var zoom=screen.width/680;
          wrapper.style.zoom = zoom;
          document.body.style.width=screen.width+'px';
        }
      });
    };
  </script>

        </head>
        <body>
            <div id="wrapper">
                
        <div class="problem">
            <div class="problem-title" id="problem-1E">
                <a href="#problem-1E">1E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p>Binary search tree (BST) is the tree in which all elements are
stored according to the following key property.</p>
<p><b>Key property of the binary search tree:</b></p>
<p>The key of a parent node <i>p</i> of a subtree in the BST, must
be greater than key of its left node <i>x</i>(i.e, <i>x.key</i>
&gt; <i>p.key</i>) and less than or equal to the key of its right
node <i>y</i>(i.e, p.key<img src=
"../imgs/85fc238ebc5be61ae632c36f3ad8ec595d986ce1.png"><i>y.key</i>).</p>
</div>
<hr>
<div class="answer">
<p>a)</p>
<p>Consider the given sequence<img src=
"../imgs/9c76b72a1b7c91c66795761605cd22625ec6155e.png">. When
searching for 363, the following given nodes are examined in the
following order.</p>
<p><img src="../imgs/f189946670607aaedbe0f3ddbb55b2ca437f6ca8.png"
alt="D:\Tiffs\all files\2254-12.2-1E.png"></p>
<p>• It is possible to draw a binary search tree with the given
sequence of numbers and also it follows the key property of binary
search tree.</p>
<p>• While searching for 363 using key property of BST, all the
given numbers are examined in the given sequence.</p>
<p><b>Thus, the given sequence could occur when searching the
number 363.</b></p>
</div>
<hr>
<div class="answer">
<p>b)</p>
<p>Consider the given sequence<img src=
"../imgs/5470c46bcd0f5caa1f9fb11d6177b9c0d7e369c1.png">. While
searching for 363, the following given nodes may examined in the
following order.</p>
<p><img src="../imgs/5f58b91b7e39dbaa5fcc37f2374274b07bddfee1.png"
alt="D:\Tiffs\all files\2254-12.2-1E.png"></p>
<p>• It is possible to draw a binary search tree with the given
sequence of numbers and also it follows the key property of binary
search tree.</p>
<p>• While searching for 363 using key property of BST, all the
given numbers are examined in the given sequence.</p>
<p><b>Thus, the given sequence could occur when searching the
number 363.</b></p>
</div>
<hr>
<div class="answer">
<p>c)</p>
<p>Consider the given sequence<img src=
"../imgs/2b8f80e4c4f948807d97c527871892b85923cb21.png">. While
searching for 363, the following given nodes may examined in the
following order.</p>
<p><img src="../imgs/46d0dcd185bc5a64155021d14d41cbb8731928ab.png"
alt="Picture 1"></p>
<p>• Observe the binary search tree drawn with the given sequence
of numbers. It is clear that, while searching the number 363, the
node 912 is not examined, because 363 is less than 911.</p>
<p><b>Thus, the given sequence of nodes could not examined when
searching for the number 363.</b></p>
<p>d)</p>
<p>Consider the given sequence<img src=
"../imgs/01b11a1e02b905aa8bf144097c0b3f78a7f2d9ef.png">. While
searching for 363, the following given nodes may examined in the
following order.</p>
<p><img src="../imgs/2a1c150199e5c3e40ef068896612eb2d6f43ff72.png"
alt="Picture 8"></p>
<p>• It is possible to draw a binary search tree with the given
sequence of numbers and also it follows the key property of binary
search tree.</p>
<p>• While searching for 363 using key property of BST, all the
given numbers are examined in the given sequence.</p>
<p><b>Thus, the given sequence could occur when searching the
number 363.</b></p>
</div>
<hr>
<div class="answer">
<p>e)</p>
<p>Consider the sequence <img src=
"../imgs/074c0a549f4a80ef735f111883ae7e06c9ac1e3d.png"> to search
the number<img src=
"../imgs/815687a4bfbe85b8507ee7f3af8d2010649346d8.png">.</p>
<p><img src="../imgs/a4a5b528c268d2a80cce8b5e694a4c3dbec721b0.png"
alt="Picture 4"></p>
<p>• Observe the binary search tree drawn with the given sequence
of numbers. It is clear that, while searching the number 363, the
node 299 is not examined, because 363 is greater than 347.</p>
<p><b>Thus, the given sequence of nodes could not examined when
searching for the number 363.</b></p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-2E">
                <a href="#problem-2E">2E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<img src="../imgs/f4eb19ab13eece940be42c99acfc2d5d6a04a704.png">
<hr>
<img src="../imgs/3356f45a58d820dad6e55b3bd774330050e167bc.png">
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-3E">
                <a href="#problem-3E">3E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p>Consider the following procedure that finds the predecessor of a
node in a tree. If no two elements in the tree are same, then the
predecessor of a node <i>x</i> is the largest key that is less than
<i>x.key</i>.</p>
<p>TREE-PREDECESSOR (<i>x</i>)</p>
<p>//check the left node of binary tree</p>
<p>1. <b>if</b> <i>x</i>.<i>left</i> <img src=
"../imgs/f13cca3eb881e0ca6c2835af852e4e0fce0c1bc7.png">NIL</p>
<p>// find maximum from left of tree</p>
<p>2. <b>return</b> TREE-MAXIMUM (<i>x.left</i>)</p>
<p>//store the parent of <i>x</i> into variable <i>y</i></p>
<p>3. <i>y</i> = <i>x.p</i></p>
<p>//condition is used to check the</p>
<p>4. <b>while</b> <i>y</i> <img src=
"../imgs/f13cca3eb881e0ca6c2835af852e4e0fce0c1bc7.png">NIL
<b>and</b> <i>x =</i> = <i>y.left</i></p>
<p>// go up by updating the node <i>x</i> and node <i>y</i></p>
<p>5. <i>x = y</i></p>
<p>6. <i>y</i> = <i>y.p</i></p>
<p>//return the value of <i>y</i> that is the predecessor of
<i>x</i>.</p>
<p>7. <b>return</b> <i>y</i></p>
</div>
<hr>
<div class="answer">
<p><b>Explanation for the Algorithm:</b></p>
<p>• The above algorithm checks for the left sub tree and if the
left subtree is not empty , then the predecessor of <i>x</i> is
maximum element in the left subtree of node <i>x</i>. it is
returned in the line 2.</p>
<p>• If the left subtree is empty, the algorithm, in the lines 3-6,
moves up from the node <i>x</i> until a node that is the right
child of its parent, is encountered. The node is returned in the
line 7.</p>
<p>The running time of TREE-PREDECESSOR is also same as the running
time of TREE-SUCCESSOR. That is, <i>O</i>(<i>h</i>). Where <i>h</i>
is the height of the tree.</p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-4E">
                <a href="#problem-4E">4E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p><b>Counter Example for Professor Bunyan Claim</b></p>
<p>Consider the binary search tree which contradicts the professor
Bunyan claim. Suppose that the key <i>k</i> in a binary search tree
ends up in a leaf. And also consider three sets:</p>
<p>A = {the keys to the left of the search path}</p>
<p>B = {the keys on the search path}</p>
<p>C = {the keys to the right of the search path}</p>
<p>And Professor Bunyan claims that any three keys <img src=
"../imgs/3368ab5fccab2bb1898489db21669b1dd411b638.png"> and
<img src="../imgs/8d166949bff60c7d61478732dd147b2a68b86565.png">
must satisfy<img src=
"../imgs/09f6359eae311fa616ece755c9afcdb0f1353cd0.png">.</p>
<p>Now, see the following figure is the counter example for
Professor Bunyan claim. Here assume that the search ended at 5. The
three sets are:</p>
<p><img src=
"../imgs/d6534e9b42afef10a520a5afc77e98f1b1dbaf70.png"></p>
<p><img src=
"../imgs/6732560b48a82f589e839a88d689609f05e13d29.png"></p>
<p><b>Example to Professor Bunyan Claim</b></p>
<p>Note that ‘2’ is present in set A but it is greater than ‘1’
present in set B.</p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-5E">
                <a href="#problem-5E">5E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p>If in-order tree walk prints a sequence …<i>xyz</i>…, then
<i>x</i> is called predecessor of <i>y</i> and <i>z</i> is called
successor of <i>y</i>.</p>
<p>For suppose, consider a node <i>A</i> that has two children
<i>B</i> and <i>C</i>, in the binary search tree. Also assume, node
<i>B</i> is the predecessor of v and the node <i>C</i> is the
successor of the v. That is , in-order tree walk algorithm prints a
sequence …<i>BAC</i>…for the following tree.</p>
<p><b><img src=
"../imgs/8d03274772d9eba74a1cebcb71adda0f45aad0a4.png" alt=
"Picture 2"></b></p>
</div>
<hr>
<div class="answer">
<p><b>Predecessor B has no right child:</b></p>
<p>• If the element <i>B</i> has a right child, then according to
the key property of binary search tree, the right child must be
greater than <i>B</i>.</p>
<p>• Thus, <i>B.right</i> will be printed after <i>B</i> and before
<i>A</i>, by the in-order tree walk. That is, the sequence printed
by the in-order tree walk is …<i>B,B.right,A,C</i>… . Hence,
<i>B</i> is not the predecessor of <i>A</i>. but, it is the
contradiction to our assumption.</p>
<p>Therefore, if <i>A</i> has two children <i>B,C</i> and <i>B</i>
is the predecessor of <i>A</i> and <i>C</i> is the successor of
<i>A</i> , then the predecessor of <i>A</i>(<i>B</i>) has no right
child. That is, <i>B.right</i> is <i>NIL.</i></p>
<p><b>Successor C has no left child:</b></p>
<p>• If the element <i>C</i> has a left child, then according to
the property of binary search tree, the <i>C.left</i> must be less
than or equal to <i>C</i>.</p>
<p>• Thus, <i>C.left</i> will be printed after <i>A</i> and before
<i>C</i>, by the in-order tree walk. That is, the sequence printed
by in-order tree walk is …<i>B</i>,<i>A,C.left,C</i>… . Hence,
<i>C</i> is not the successor of <i>A</i>. but, it is the
contradiction to our assumption.</p>
<p>Therefore, if <i>A</i> has two children <i>B,C</i> and <i>B</i>
is the predecessor of <i>A</i> and <i>C</i> is the successor of
<i>A</i> , then the successor of <i>A</i>(<i>C</i>) has no left
child.</p>
<p><b>Hence, if a node in the binary search tree has two children,
then its predecessor has no right child and its predecessor has no
right child.</b></p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-6E">
                <a href="#problem-6E">6E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p>If <i>x</i> is a node in a binary search tree <i>T</i>, then the
nodes that are on the path from <i>x</i> to the root <i>T</i> are
called the ancestors of the node <i>x</i>. Also the successor of
node <i>x</i> in a binary search tree <i>T</i>, is the node with
<i>key</i> that is smallest key greater than <i>x.key</i>.</p>
<p>Consider the following procedure to find the successor of the
node <i>x</i>:</p>
<p>TREE-SUCCESSOR(x)</p>
<p>1. <b>if</b> <i>x.right</i> <img src=
"../imgs/f13cca3eb881e0ca6c2835af852e4e0fce0c1bc7.png">NIL</p>
<p>2. <b>return</b> minimum in the right sub tree of x</p>
<p>3. <i>y</i> = <i>x.p</i></p>
<p>4. <b>while</b> <img src=
"../imgs/5996b379322269b7f70a7bfda7bd1cb20f03a87a.png"> and
<i>x</i> = = <i>y.right</i></p>
<p>5. <i>x</i> = <i>y</i></p>
<p>6. <i>y</i> = <i>y.p</i></p>
<p>7. <b>return</b> <i>y</i></p>
<p>The above procedure returns the minimum of right sub tree of
<i>x</i>, if the right sub tree is not empty. Otherwise, the
procedure returns <i>y</i>. where <i>y</i> is the lowest ancestor
of <i>x</i>, whose left child is <i>x</i> or an ancestor of
<i>x.</i></p>
</div>
<hr>
<div class="answer">
<p><b>Proving that if the right sub tree of</b> <i><b>x</b></i>
<b>is empty, then successor of</b> <i><b>x</b></i> <b>is the lowest
ancestor of</b> <i><b>x</b></i> <b>, whose left child is also and
an ancestor of</b> <i><b>x</b></i> <b>:</b></p>
<p>• Consider a binary search tree <i>T</i> and suppose that the
right sub tree of node <i>x</i> in <i>T</i> is empty.</p>
<p>• According to the definition of binary search tree, the
successor of a node <i>x</i> is the lowest key greater than
<i>x.key</i>.</p>
<p>• If the right subtree of <i>x</i> is empty, then there exist a
subtree <img src=
"../imgs/7d4ad431f97ecc3e1c60c2f3580d663cca71f14a.png"> that
contains the node <i>x</i> such that the root(<i>S</i>) of
<img src="../imgs/7d4ad431f97ecc3e1c60c2f3580d663cca71f14a.png"> is
less than or equal to <i>x</i> and parent of <i>S</i> (<i>y</i>) is
greater than <i>x.key</i>. Since, <i>y</i> is greater than
<i>S</i>, <i>S</i> is the left child of <i>y</i>.</p>
<p>• Now, obviously, <i>y</i> is the successor of <i>x</i>. That
is, <i>y</i> is the lowest ancestor of <i>x</i> whose left
child(<i>S</i>) is also ancestor of <i>x</i>. sometimes, <i>S</i>
is equal to <i>x</i>.</p>
<p>• Thus, if there exist such a sub tree<img src=
"../imgs/7d4ad431f97ecc3e1c60c2f3580d663cca71f14a.png">, then
<i>y</i> is the successor of <i>x</i>. otherwise, the successor is
<i>NIL</i>.</p>
<p>If the right sub tree of <i>x</i> is empty, lines from 3-7 of
TREE-SUCCESSOR find the successor of <i>x.</i> That is, the
procedure climbs up to find an ancestor of <i>x</i>(<i>S.p</i>),
whose left child(<i>S</i>) is also an ancestor of <i>x</i>.</p>
<p>• If right sub tree of <i>x</i> is empty, then the parent of
<i>x</i> becomes <i>y</i>. That is, <i>y</i> is an ancestor of
<i>x</i>.</p>
<p>• In Line 4, the while loop is executed until there is a parent
<i>y</i> for <i>x</i> and <i>x</i> is the right child of <i>y</i> .
That is, each time the while loop finds an ancestor(<i>y</i>) of
<i>x</i>.</p>
<p>• In each iteration of the while loop, <i>y</i> becomes the
parent of <i>x</i>. while loop breaks when <i>x</i> becomes the
right child of <i>y</i>. Then, <i>y</i> returned as the successor
of <i>x.</i> where <i>y</i> is the lowest ancestor of <i>x</i>,
whose left child is also an ancestor of <i>x</i>.</p>
<p><b>Therefore, if the right subtree of a node</b> <i><b>x</b></i>
<b>in a binary search tree</b> <i><b>T</b></i> <b>is empty and</b>
<i><b>x</b></i> <b>has a successor</b> <i><b>y</b></i> <b>,
then</b> <i><b>y</b></i> <b>is the lowest ancestor of</b>
<i><b>x</b></i> <b>whose left child is also an ancestor of</b>
<i><b>x.</b></i></p>
</div>
<hr>
<div class="answer">
<p><b>Example:</b></p>
<p>Consider the following binary search tree</p>
<p><img src="../imgs/deaf67278d8a900459eecf169aecfca28acc226d.png"
alt="34"></p>
<p><b>Finding the successor of the node with key 13:</b></p>
<p>1. Since the node 13 has no right sub tree, node 7 becomes the
y. Also, <i>x</i> is the right child of <i>y</i>.</p>
<p>2. Therefore, node 6 becomes the <i>y</i> and node 7 becomes
<i>x</i>.</p>
<p>3. Since, the node 7 is the right child tree of 6, node15
becomes <i>y</i> and node 6 becomes <i>x</i>.</p>
<p>4. But now, the node 6 is not right child of 15.</p>
<p>5. Therefore, node 15 is returned as the successor of 13.</p>
<p><b>Here, 15 is the lowest ancestor of 13, whose left child (6)
is also an ancestor of 13.</b></p>
<p><b>Finding the successor of the node with key 17:</b></p>
<p>1. Since the node 17 has no right sub tree, node 18 becomes the
<i>y.</i></p>
<p>2. But node 17 is not the right child of node 18.</p>
<p>3. Therefore 18 is returned as the successor of node 17.</p>
<p><b>Here, 18 is the lowest ancestor of 13, whose left child (13)
is also an ancestor of 13.(a node is its own ancestor) .</b></p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-7E">
                <a href="#problem-7E">7E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<img src="../imgs/a862a9987514a9dd471f0a4b33dbc7c53402915d.png">
<hr>
<img src="../imgs/45a23048c84a1d643543a9d12bd399cfe9e3d255.png">
<hr>
<img src="../imgs/5e5b4157f205a10bccccdc53ba853e853906bc98.png">
<hr>
<img src="../imgs/eb3f971d17ca6c00f85030c5f864991a7f48d446.png">
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-8E">
                <a href="#problem-8E">8E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p>• Let <i>x</i> be the starting node and <i>y</i> be the ending
node after <i>k</i> successive calls to TREE-SUCCESSOR.</p>
<p>• Let <i>p</i> be the simple path between <i>x</i> and
<i>z</i>.</p>
<p>• Let <i>z</i> be the lowest common ancestor of <i>x</i> and
<i>y</i> that is visited by the path <i>p</i>.</p>
<p>• The length of the path <i>p</i> is at most <img src=
"../imgs/f9043188701681864446a7c9209aef44a70352a2.png">.Successive
calls will never traverse a single edge more than twice since
TREE-SUCCESSOR acts like a tree traversal, so never examine a
single vertex more than 3 times.</p>
<p>• Let the output be the elements that their values are between
x.key and y.key. The size of the output is <img src=
"../imgs/426968b8378dcd0b5bdadbd1a0f10c5f10c8085a.png">. Any vertex
whose key value is not between <i>x</i> and <i>y</i> will be
examined only once and it will occur on a simple path from <i>x</i>
to <i>y</i> or <i>z</i> to <i>y.</i></p>
</div>
<hr>
<div class="answer">
<p>Thus, in the execution of <i>k</i> successive calls to
TREE-SUCCESSOR the nodes that are in the path <i>p</i> are visited
and besides the nodes <i>x</i>, <i>y</i> and <i>z</i>, if a subtree
of a node in <i>p</i> is visited then all its elements are in the
output.</p>
<p>The running time is: <img src=
"../imgs/79197c81b4d92eee2f3c234ac4e56fa7c9235cec.png"></p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-9E">
                <a href="#problem-9E">9E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p>Consider T be a binary tree whose keys are distinct. We define
the successor and predecessor of any node x as the node returned by
calls made to TREE-SUCCESSOR(x) and TREE-PREDECESSOR(x).Let x be a
leaf node, and y is parent. The figure shown below:</p>
</div>
<hr>
<div class="answer">
<p><u><b>Binary search tree (T)</b></u> :</p>
<p><img src=
"../imgs/bf833a155a9ddcf4fb15cda16020829e9257c28b.png"></p>
</div>
<hr>
<div class="answer">
<p>If x is a leaf node, then if p[x] = y and x is the left child
then running TREE SUCCESSOR yields y.consider the following binary
search tee is.</p>
<p><u>Example</u>:</p>
<p><img src=
"../imgs/a3a017f87e29839d8268625fde765b3aa367f3df.png"></p>
</div>
<hr>
<div class="answer">
<p>Here y.key (6) is either the smallest key in T or larger than
x.key (5). Similarly if x is the right child then running TREE
PREDECESSOR yields y.</p>
</div>
</body>
</html>

            </div>     
        </div> 
        
            </div>    
            <div class="info">
                Chegg Rip, Introduction to Algorithms, 3rd Edition. [RipVer 0.1]
            <a href="../index.html">
                (index)
            </a>
            </div>
            <a class="return-float-btn" href="../index.html">
                <span class="arrow-left icon"/>    
            </a>
        </body>
        </html>
        