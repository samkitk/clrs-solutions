<!doctype html>
        <html lang="en">
        <head>
          <meta charset="utf-8">
          <title>Chapter 22.2</title>
          <link rel="stylesheet" href="../style.css">
          
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script>
    window.onload=function(){
      setTimeout(function(){
        if(screen.width<680){
          var wrapper=document.getElementById('wrapper');
          var zoom=screen.width/680;
          wrapper.style.zoom = zoom;
          document.body.style.width=screen.width+'px';
        }
      });
    };
  </script>

        </head>
        <body>
            <div id="wrapper">
                
        <div class="problem">
            <div class="problem-title" id="problem-1E">
                <a href="#problem-1E">1E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p>Consider the breadth-first search to apply on the directed graph
given in the Figure 22.2(a). In the breadth-first search, <img src=
"../imgs/415509d4931772c81be3967bb583d0be9357cd9b.png">value of a
vertex represents the predecessor of that node and <img src=
"../imgs/f42faa495a84c51e4735d142a7151a075de2051d.png">value of a
vertex represents the distance of that node from the source.</p>
<p>• Here, for every vertex<img src=
"../imgs/0bc2ad5e51264a119e4ce38d7f1fd10ecfc1339c.png">, the
predecessor or <img src=
"../imgs/415509d4931772c81be3967bb583d0be9357cd9b.png">value of
<img src="../imgs/1b38f8f10d9f96612098da0ffc1a6d70ffeeb140.png">is
stored in the attribute<img src=
"../imgs/4aa530176e63979a202a124f1ba62947e4b96e2f.png">.</p>
<p>• If <img src=
"../imgs/6e2b38ab5a70b05996a42d0fcd2a3a42b37b86b7.png">or <img src=
"../imgs/1b38f8f10d9f96612098da0ffc1a6d70ffeeb140.png">has not been
discovered, then <img src=
"../imgs/4aa530176e63979a202a124f1ba62947e4b96e2f.png">is set to
NIL.</p>
<p>• The distance from the source to a vertex<img src=
"../imgs/1b38f8f10d9f96612098da0ffc1a6d70ffeeb140.png">is stored in
the attribute<img src=
"../imgs/b06faf3f9cfa576a028a0a27378d0705b76f3c6e.png">.</p>
</div>
<hr>
<div class="answer">
<p>Now, consider the following figure 22.2(a) to run the
breadth-first search on it.</p>
<p>Here, <img src=
"../imgs/7017c72b62f8f3f1d14818efd9591d81ec9ba902.png">consists the
set of GREY vertices.</p>
<p><b>Step 1:</b></p>
<p>Start with the vertex 3 as the source. So, set <img src=
"../imgs/415509d4931772c81be3967bb583d0be9357cd9b.png">value of the
vertex 3 to NIL and the value of <img src=
"../imgs/f42faa495a84c51e4735d142a7151a075de2051d.png">is zero.
Place the vertex 3 at the tail of the queue Q.</p>
<p>Hence, <img src=
"../imgs/7017c72b62f8f3f1d14818efd9591d81ec9ba902.png">consists
vertex 3.</p>
<p><img src="../imgs/c0f9a2ec5bb39ce0cebacbd7d7035792d31dc468.png"
alt=
"D:\2015 FILES\MONTHS 2015\9 September\24.9.2015\Bibek 2254\Image\8.png"></p>
</div>
<hr>
<div class="answer">
<p><b>Step 2:</b></p>
<p>Since 3 is the head of the queue, insert the next adjacent nodes
of 3(5,6) into the Q and set the <img src=
"../imgs/415509d4931772c81be3967bb583d0be9357cd9b.png">values of
the vertex 5 and vertex 6 to 3. The distance of vertex 5 (5.d) and
vertex 6(6.d) from the source is 1. Remove 3 from the Q.</p>
<p>Hence, <img src=
"../imgs/7017c72b62f8f3f1d14818efd9591d81ec9ba902.png">consists the
GREY vertices 5 and 6.</p>
<p><img src="../imgs/ab8b724fc2dd8c78d86c3f468ed3a4ec2b72cb72.png"
alt=
"D:\2015 FILES\MONTHS 2015\9 September\24.9.2015\Bibek 2254\Image\9.png"></p>
</div>
<hr>
<div class="answer">
<p><b>Step 3:</b></p>
<p>Now, the head of the queue is 5. Therefore insert the adjacent
vertices of 5(4) into Q and set the <img src=
"../imgs/415509d4931772c81be3967bb583d0be9357cd9b.png">value of the
vertex 4 to 5. The distance of vertex 4(4.d) is 2. Remove the
vertex 5 from the Q.</p>
<p>Hence, <img src=
"../imgs/7017c72b62f8f3f1d14818efd9591d81ec9ba902.png">consists the
GREY vertices 6 and 4.</p>
<p><img src="../imgs/0d8814091b21ca634a683a83bd339677dd21d096.png"
alt=
"D:\2015 FILES\MONTHS 2015\9 September\24.9.2015\Bibek 2254\Image\10.png"></p>
<p><b>Step 4:</b></p>
<p>Here, the head of the queue is vertex 6. But, there are no
adjacent vertexes to 6 except itself. Since the vertex 6 is already
visited, remove 6 from the Q .Hence, <img src=
"../imgs/7017c72b62f8f3f1d14818efd9591d81ec9ba902.png">consists
only the vertex 4.</p>
<p><img src="../imgs/dd8cb7fe9ef229172a985a14ebecc96ace57f7ad.png"
alt=
"D:\2015 FILES\MONTHS 2015\9 September\24.9.2015\Bibek 2254\Image\11.png"></p>
</div>
<hr>
<div class="answer">
<p><b>Step 5:</b></p>
<p>Now, head of the queue is vertex 4. Thus, insert the adjacent
vertexes of vertex 4(2) into Q and set the <img src=
"../imgs/415509d4931772c81be3967bb583d0be9357cd9b.png">value of the
vertex 2 to 4 and the distance of 2(2.d) as 3. Remove the vertex 4
from the Q. Hence, <img src=
"../imgs/7017c72b62f8f3f1d14818efd9591d81ec9ba902.png">consists the
GREY vertex 2 only.</p>
<p><img src="../imgs/39abd0f8b881125684ec8a191aa50329cab5d202.png"
alt=
"D:\2015 FILES\MONTHS 2015\9 September\24.9.2015\Bibek 2254\Image\12.png"></p>
<p><b>Step 6:</b></p>
<p>Here, the head of the queue is 2 and its successor is 5. Since
vertex 5 is already visited and there are no vertexes to process,
remove the vertex 2 from the Q. set the <img src=
"../imgs/415509d4931772c81be3967bb583d0be9357cd9b.png">value of the
vertex 1 to Nil, because the predecessor of vertex 1 is not
defined.</p>
<p><img src="../imgs/a13165ffa538add1c8b637e733c10f7e7e314f48.png"
alt=
"D:\2015 FILES\MONTHS 2015\9 September\24.9.2015\Bibek 2254\Image\13.png"></p>
</div>
<hr>
<div class="answer">
<p>Hence, after running the bread-first search on the given graph,
the <img src=
"../imgs/415509d4931772c81be3967bb583d0be9357cd9b.png">values and
<img src=
"../imgs/f42faa495a84c51e4735d142a7151a075de2051d.png">values of
each vertex are as follows:</p>
<table border="1" style="border-collapse:collapse;">
<tr>
<td>
<p><b>Node</b></p>
</td>
<td>
<p><b><img src=
"../imgs/415509d4931772c81be3967bb583d0be9357cd9b.png"></b>
<b>values</b></p>
</td>
<td>
<p><b><img src=
"../imgs/f42faa495a84c51e4735d142a7151a075de2051d.png"></b>
<b>values</b></p>
</td>
</tr>
<tr>
<td>
<p>3</p>
</td>
<td>
<p>NIL</p>
</td>
<td>
<p>0</p>
</td>
</tr>
<tr>
<td>
<p>5</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>1</p>
</td>
</tr>
<tr>
<td>
<p>6</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>1</p>
</td>
</tr>
<tr>
<td>
<p>4</p>
</td>
<td>
<p>5</p>
</td>
<td>
<p>2</p>
</td>
</tr>
<tr>
<td>
<p>2</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>3</p>
</td>
</tr>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>NIL</p>
</td>
<td>
<p><img src=
"../imgs/7e34a007bd835dc92ad9c46a7cd5fa86919a169b.png"></p>
</td>
</tr>
</table>
<p>In the above table, the distance of node 1 from source is
<img src=
"../imgs/7e34a007bd835dc92ad9c46a7cd5fa86919a169b.png">,because
there is no path exists from any vertex to vertex 1.</p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-2E">
                <a href="#problem-2E">2E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<img src="../imgs/045d72a6311a95416ab5572766099ca1d783b960.png">
<hr>
<img src="../imgs/5263e975bf647b2e00acb478ef27518e3a0cfd55.png">
<hr>
<img src="../imgs/2880ce49907147f082749c1f7313ba2825a05c7f.png">
<hr>
<img src="../imgs/16a3e70a62bec95c91d4bee244176b894063571a.png">
<hr>
<img src="../imgs/dff0d0132b8c5a5538f19fb2806f4c4135ad89a0.png">
<hr>
<img src="../imgs/c2327e82cb3e1a002cc52202296674c0e7bba2ab.png">
<hr>
<img src="../imgs/9f6f9c7fdbf34a51011b29791ae495db70ce3bfa.png">
<hr>
<img src="../imgs/47517ec3deeb483c323ad163918d0102dfd41843.png">
<hr>
<img src="../imgs/8af43a7284160219c5cb199bb49e452d6225e337.png">
<hr>
<img src="../imgs/78015d6fab85ae1ff2eb047c7c0f9bd80fd4aab8.png">
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-3E">
                <a href="#problem-3E">3E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p>Consider the BFS procedure discussed in the textbook. In this
procedure, every vertex is initialized with the color WHITE.</p>
<p>• After initializing, the color of the node changed to GRAY when
the node is once visited or traversed and en-queued.</p>
<p>• At the end, when these vertex will be de-queued and each
neighbor vertex is visited then the color of these vertices will be
set to BLACK.</p>
<p>• So, from the given algorithm, it can be said that the color of
a given node retain it color GRAY during a period, which ends from
the point when these vertices are en-queued to the point when it is
de-queued, followed by the step to traverse each neighbor’s
vertex.</p>
<p>Therefore, a vertex consists the GRAY color, it means these
<b>vertices exists in the queue</b>.</p>
<p>Now, consider the <b>Line 5</b> and <b>14</b>, which are used to
set the color of the vertex to GRAY, should be removed, in order to
use a <b>single bit</b> to store each vertex color.</p>
<p>• In other words, no such lines exists in the entire BFS
procedure that distinguish BLACK from GRAY.</p>
<p>• The BFS procedure only checks either it is non-WHITE or WHITE,
which shows that there is no meaning to have <b>two colors to
represent ‘visited’ vertices.</b></p>
<p>• Therefore, BFS procedure will produce the same result if the
lines 5 and 14 of the BFS procedure are removed.</p>
<p><b>Hence, a single bit is sufficient to store every vertex
color.</b></p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-4E">
                <a href="#problem-4E">4E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p>BFS() algorithm given in the text book uses adjacency-list
representation of the graph and thus its running time is <img src=
"../imgs/9492fc751e7e7575f46f3d2c8159659dbf98fb4c.png">.</p>
<p>• At-most each vertex is enqueued once and also dequeued at most
once. The time taken by enqueuing and dequeuing is <img src=
"../imgs/5348248797038408019902edf6f75aa3b51f3a98.png"> time so the
total time given to enqueue and dequeue is <img src=
"../imgs/860802824c9ca26a5dea931f4753a5807dc096f5.png">.</p>
<p>• After dequeuing the vertices, BFS() scans the adjacency list
at most once and sum of the lengths of all adjacency list
is<img src="../imgs/a5195af1b5d4708d185118c955ae4fed75eff5d8.png">,
so total time required for scanning adjacency lists is<img src=
"../imgs/3f17d605d8738f934b7f28c94da39dbae65c6c2f.png">.</p>
<p>• Hence, the time complexity of BFS() is <img src=
"../imgs/9492fc751e7e7575f46f3d2c8159659dbf98fb4c.png">.</p>
</div>
<hr>
<div class="answer">
<p><b>Running time of BFS() with adjacency matrix:</b></p>
<p>Consider that the graph is represented by its adjacency matrix
representation and it is passed to the BFS() algorithm</p>
<p>• At-most each vertex is enqueued once and also dequeued at most
once. The time taken by enqueuing and dequeuing is <img src=
"../imgs/5348248797038408019902edf6f75aa3b51f3a98.png"> time so the
total time given to enqueue and dequeue is <img src=
"../imgs/860802824c9ca26a5dea931f4753a5807dc096f5.png">.</p>
<p>• After dequeuing the vertices, BFS() scans the adjacency matrix
for adjacency vertices. In each iteration of for loop, one row of
adjacency matrix is scanned. So for one iteration it takes
<img src="../imgs/860802824c9ca26a5dea931f4753a5807dc096f5.png">time.
Since this for loop executes <i>V</i> times, scanning process takes
<img src=
"../imgs/db45ac8af2ff21196a0dd212ea45f32591cea9fc.png">time.</p>
<p>• That is BFS() takes <img src=
"../imgs/db45ac8af2ff21196a0dd212ea45f32591cea9fc.png">time to scan
whole rows and columns of adjacency matrix.</p>
<p><b>Hence, the time complexity of BFS() becomes</b> <b><img src=
"../imgs/db45ac8af2ff21196a0dd212ea45f32591cea9fc.png"></b>
<b>.</b></p>
</div>
<hr>
<div class="answer">
<p><b>Modification to BFS() so that it can handle adjacency
matrix:</b></p>
<p>Consider the BFS () algorithm provided in section 22.2 and make
the following modification in the BFS () algorithm to take input
from adjacency matrix.</p>
<p>• Replace, 12<sup>th</sup> line of BFS () algorithm with
“<img src="../imgs/f6f77f5c5259e82047468c2d63627b60864c516f.png">to
<img src="../imgs/0969cb112621fda649bb6227c14e287692b44a17.png">
”.</p>
<p>• Also replace 13<sup>th</sup> line of BFS() algorithm with
“<img src="../imgs/26efef9452220d56f8fc63cc7dae26ed3ab03682.png">”
.</p>
<p>• Rest of the code requires no modification. So, rest of the
code will be same.</p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-5E">
                <a href="#problem-5E">5E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p>Breadth-first search(BFS) is a searching algorithm. If
<i>G</i>=(<i>V,E</i>) is a graph and <i>s</i> is the source vertex,
then the BFS explores the edges symmetrically to search each vertex
that is reachable from the source <i>s</i>. While searching, BFS
computes the shortest distance in terms of edges from <i>s</i> to
each reachable vertex.</p>
<p>• Breadth-first search starts at the source vertex s. Thus, in
line 9, <i>s</i> is inserted into queue first.</p>
<p>• Until the queue is not empty, each time BFS dequeue a vertex
<i>u</i>(line 11), and explores unvisited adjacent vertices of
<i>u</i>( that are colored white).</p>
<p>• In line 12, BFS takes each adjacent vertex of <i>u</i> and
updates the distance of it from source, only if that adjacent
vertex is unvisited (colored white).</p>
<p>• Here the search is considering only whether the adjacent
vertex is already visited or not, but not considering the order of
vertices (That is, which vertex is to be taken first).</p>
<p>• If the adjacent vertex color is gray or black (i.e., already
visited or discovered), the distance is not altered. Thus the
shortest distance is not affected by the order. Also the proof of
theorem 22.5 shows that the distance <img src=
"../imgs/89fdb47640ddeafcd64bf1a8fe01fe8dfa822c76.png">.</p>
<p><b>Thus the order of adjacent vertices in adjacency lists,
affects the bread-first search (breadth first tree), but not the
distances.</b></p>
<p><b>Consider the figure 22.3 as example.</b></p>
</div>
<hr>
<div class="answer">
<p><b>Proving that the BFS tree depends on the ordering within
adjacency lists:</b></p>
<p><b><img src=
"../imgs/07c9e23f35d38eba006005a1c5f752682568ffaa.png" alt=
"Picture 9"></b></p>
<p>To prove that the BFS tree depends on the ordering within
adjacency lists, consider the following two different adjacency
lists for the above graph. The difference between these two lists
is , <i>t</i> precedes <i>x</i> in <i>adj</i>[<i>w</i>] in first
list and <i>x</i> precedes <i>t</i> in <i>adj</i>[<i>w</i>].</p>
<p><b><img src=
"../imgs/d5cd389f9fccccbc95150381ad0b9c59da186e6b.png" alt=
"Picture 14"></b></p>
</div>
<hr>
<div class="answer">
<p><b>Consider the adjacency list(a) and run BFS tree as
follows:</b></p>
<p>• Initially the queue contains the source vertex <i>s</i>. That
is <i>s</i> is visited first.</p>
<p>• Now, the adjacent vertices of <i>s</i> are visited according
to order of the adjacency list of <i>s</i>.</p>
<p>• Thus <i>w</i> is visited first and then <i>v</i> is visited
next. That is <i>w</i> is enqueued first, then <i>v</i>. Hence,
edges (<i>s,w</i>) and (<i>s,v</i>) are added to binary search
tree.</p>
<p>• Next, adjacent vertex of <i>w</i> are visited in the order,
<i>t</i>, <i>x</i>, respectively. Hence, edges (<i>w,t</i>) and
(<i>w,x</i>) are added to binary search tree.</p>
<p>• Now, the adjacent vertex <i>v</i> of <i>r</i> is visited.
Hence, the edge (<i>r,v</i>) is added to binary search tree.</p>
<p>• Next adjacent vertex of <i>t</i>, <i>u</i> is visited. Hence
the edge (<i>t,u</i>) is added to binary serach tree.</p>
<p>• Next adjacent vertex of <i>x</i>, <i>y</i>, is visited. Hence
the edge (<i>x,y</i>) is added to binary search tree.</p>
<p><b>Now the BFS tree and BFS graph will be as follows:</b></p>
<p><b><img src=
"../imgs/d82dd3f7da86aa712d444e406d77e7967f757ce7.png" alt=
"Picture 17"></b></p>
</div>
<hr>
<div class="answer">
<p><b>Consider the adjacency list(b) and run BFS tree as
follows:</b></p>
<p>• Initially the queue contains the source vertex <i>s</i>. That
is <i>s</i> is visited first.</p>
<p>• Now, the adjacent vertices of <i>s</i> are visited according
to order of the adjacency list of <i>s</i>.</p>
<p>• Thus <i>w</i> is visited first and then <i>v</i> is visited
next. That is <i>w</i> is enqueued first, then <i>v</i>. Hence,
edges (<i>s,w</i>) and (<i>s,v</i>) are added to binary search
tree.</p>
<p>•</p>
</div>
<hr>
<div class="answer">Next, adjacent vertexes of <i>w</i> are visited
in the order, <i>x</i>, <i>t</i>, respectively. Hence, edges
(<i>w,t</i>) and (<i>w,x</i>) are added to binary search tree.
<p>• Now, the adjacent vertex <i>v</i> of <i>r</i> is visited.
Hence, the edge (<i>r,v</i>) is added to binary search tree.</p>
<p>• Next adjacent vertices of <i>x</i>, <i>u</i> and <i>y</i> are
visited. Hence the edge (<i>x,u</i>) and (<i>x,y</i>) are added to
binary search tree.</p>
<p><b>Now the BFS tree and BFS graph will be as follows:</b></p>
<p><img src="../imgs/563d8d6d9cb9cdee111182d614a415da27b5cba7.png"
alt="Picture 18"></p>
<p><b>By observing the two binary search trees, it can be concluded
that the binary search depended on the order of vertices</b>
<b>within adjacency lists.</b></p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-6E">
                <a href="#problem-6E">6E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p>Consider the following example graph:</p>
<p><img src="../imgs/506fffb4ee1651274152b8f8c35fcf2246884998.png"
alt="D:\My work\2016\MAY\28.05.2016\Pulkit\Image\6.jpg"></p>
<p>• Now consider the set of tree edges <img src=
"../imgs/5fcefc43eba1351e12f375bd776faa070f0cd1e0.png"> as {AB, AC,
BE, CD}</p>
<p>• Now start BFS() algorithm with A as a source. No matter how
the vertices are ordered, it will never produce the set of edges
which is equals to<img src=
"../imgs/d3b7ed9f6f42c1f6f21c6640a135bf56a1427467.png">.</p>
<p>• If non tree edges {BD,CE}are removed from G, then the graph
<img src="../imgs/c1a6523b0d3626383307d429c5c381ece789df9a.png">
will be obtained. For each vertex <i>v</i> in <i>V</i>, unique
simple path in <img src=
"../imgs/53bbf3e0fc50474fe1bfcf2b2cd0470a225d205d.png"> from A to
<i>v</i> is a shortest path in <i>G</i>.</p>
</div>
<hr>
<div class="answer">
<p>Run BFS on above graph with A as a source vertex and consider
that in the adjacency list B comes before C.</p>
<p>• B will be enqueued into the queue.</p>
<p>• After that, C will be enqueued and since all neighbours of A
are explored. A will be colored as black.</p>
<p>• Now B will be dequeued and all neighbors of B will be enqueued
i.e. E and D, no matter what their orders are in list of B and B
will be marked as black since all its neighbors are visited.</p>
<p>• After that, C,E and then D will be marked as black.</p>
<p>After the completion of BFS, the set of edges produced are {AB,
AC, BE, BD}. This set is not equals to <img src=
"../imgs/d3b7ed9f6f42c1f6f21c6640a135bf56a1427467.png">.</p>
</div>
<hr>
<div class="answer">
<p>Now consider that, in the adjacency list C comes before B. Then
the set of tree edges that are produced will be changed.</p>
<p>• C will be enqueued into the queue and hence dequeued too.</p>
<p>• After that B will be enqueued. Since all neighbours of A are
explored, A will be colored as black.</p>
<p>• Now C will be dequeued and then all neighbors of C will be
enqueued i.e. E and D, no matter what their orders are in list of C
and C will be marked as black, since all its neighbors are
visited.</p>
<p>• After that B, E and then D will be marked as black.</p>
<p>After the completion of the BFS, the set of tree edges produced
are {AB, AC, CE, CD}. This set is not equals to <img src=
"../imgs/d3b7ed9f6f42c1f6f21c6640a135bf56a1427467.png">.</p>
<p><b>In both cases, no matter what the order is for the vertex in
adjacency list, BFS never produces the set of edges</b>
<b><img src="../imgs/d3b7ed9f6f42c1f6f21c6640a135bf56a1427467.png"></b>
<b>.</b></p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-7E">
                <a href="#problem-7E">7E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<img src="../imgs/1ef0582c503a33c2579d443ff24ac2ede2432618.png">
<hr>
<img src="../imgs/2613a89494c2d87c3373b68f67ef5cef2cbb004c.png">
<hr>
<img src="../imgs/13a68df91fe2f5185871966905214bc668f322ec.png">
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-8E">
                <a href="#problem-8E">8E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p><b>Computing the diameter of a tree</b></p>
<p>Consider that <img src=
"../imgs/6a6a461608a4271bcd7e9e59bdecadd1a5a85f83.png"> be a tree
and <img src=
"../imgs/6611513c323d308bf5aa110f5b61d5e17e2d25a6.png"> is the
shortest distance for any two vertices <img src=
"../imgs/29920df19f2ab74aa6b7c822e3c753a780e53178.png"> of
<i>T</i>. Then the diameter of tree <i>T</i> can be defined as the
longest shortest path distance among all shortest distances in
<i>T</i>. That is diameter (<i>D</i>) of a tree <i>T</i> is
<img src=
"../imgs/7fc9106e0a8d65bd4c2a21e14ddb19655df7a0ff.png">.</p>
</div>
<hr>
<div class="answer">
<p><b>Algorithm for computing the diameter (</b> <i><b>D</b></i>
<b>):</b></p>
<p>• It is known that Breadth First Search (BFS) algorithm computes
shortest path distances from a source vertex <i>s</i> to other
vertices in the graph.</p>
<p>• Maximum shortest path can be computed by running BFS on every
node in the tree and identifying a vertex that is farthest from the
source such that the distance is greater than the shortest distance
between any two nodes in the tree.</p>
<p>DIAMETER(<i>T</i>)</p>
<p>1 <i>Diameter</i> = 0</p>
<p>2 <b>for</b> each vertex <i>u</i> belongs to
<i>T</i>.<i>V</i></p>
<p>3 Apply BFS(<i>u</i>) and find a node <i>v</i> such that the
<img src="../imgs/6611513c323d308bf5aa110f5b61d5e17e2d25a6.png"> is
the longest shortest path</p>
<p>4 <b>if</b> <img src=
"../imgs/6611513c323d308bf5aa110f5b61d5e17e2d25a6.png">&gt;
<i>Diameter</i></p>
<p>5 <i>Diameter</i>=<img src=
"../imgs/6611513c323d308bf5aa110f5b61d5e17e2d25a6.png"></p>
<p>6 <b>return</b> <i>Diameter</i></p>
<p>The above algorithm runs BFS on all vertices (That is, <img src=
"../imgs/0969cb112621fda649bb6227c14e287692b44a17.png"> times) .
Since the BFS runs in <img src=
"../imgs/8fd1a29fbb656c321c9dda2aa9d6532137e056b9.png"> time, the
above algorithm runs in <img src=
"../imgs/050d2fd2acab0bda7e3df21f15bba35b3f5fff49.png"> .</p>
</div>
<hr>
<div class="answer">
<p><b>Efficient algorithm for computing the diameter (</b>
<i><b>D</b></i> <b>):</b></p>
<p>The above mentioned algorithm finds the diameter of a tree in
<img src=
"../imgs/cbe2fa7f05f1fa3131600573263143687dfff6a2.png">time.
<img src="../imgs/cbe2fa7f05f1fa3131600573263143687dfff6a2.png"> is
not a linear time. There is an efficient dynamic programming
algorithm that runs linearly, to find diameter of a tree.</p>
<p>• The diameter of a tree may or may not pass through the root of
the tree.</p>
<p>• If the root is exist in the path of the diameter, then the
depth from the root is the diameter.</p>
<p>• Otherwise, the diameter of the tree will be the diameters of
the subtrees. Depths can be calculated easily and diameter of sub
trees can be calculated recursively.</p>
<p>Examples:</p>
<p><img src="../imgs/f087f549aa587759ec5e6210479db1ea747405cf.png"
alt="Picture 1"></p>
</div>
<hr>
<div class="answer">
<p>Diameter of a tree can be computed using dynamic programming
approach. The following recursive algorithm finds the diameter of a
tree:</p>
<p>DIAMETER(<i>y</i>)</p>
<p>1 <b>if</b> <i>y</i> is leaf node</p>
<p>2 <b>return</b> 0</p>
<p>3 <i>maxDiameter</i>=0</p>
<p>4 <b>for</b> each <i>child</i><sub>i</sub> of <i>y</i></p>
<p>5 <i>tempDiameter</i>=DIAMETER(<i>y.child</i>)</p>
<p>6 <b>if</b> <i>tempDiameter</i> &gt; <i>maxDiameter</i></p>
<p>7 <i>maxDiameter</i> = <i>tempDiameter</i></p>
<p>8 <i>maxDepth</i>=0</p>
<p>9 <b>for</b> every pair of children (<i>u,v</i>) of <i>y</i></p>
<p>10
<i>depth</i><b>=d(</b><i><b>y.child</b></i><sub>i</sub><b>)+d(</b><i><b>y.child</b></i><sub>j</sub><b>)</b></p>
<p>11 <b>if</b> <i>depth</i>&gt; <i>maxDepth</i></p>
<p>12 <i>maxDepth</i> =<i>depth</i></p>
<p>13 <i>maxDepth</i> = <i>maxDepth</i> +2</p>
<p>14 <b>if</b> <i>maxDiameter</i> &gt; <i>maxDepth</i></p>
<p>15 return <i>maxDepth</i></p>
<p>16 <b>else</b></p>
<p>17 return <i>maxDiameter</i></p>
<p>To calculate the diameter of a tree , call DIAMETER(root).</p>
<p>• In line 1, the above algorithm returns 0 if the node <i>y</i>
is a leaf node.</p>
<p>• in lines 4-8, the diameters of sub trees of the tree having
<i>y</i> as root node are calculated and maximum diameter is stored
in <i>maxDiameter</i>.</p>
<p>• In lines 9-13, the depths of child nodes of <i>y</i> are
calculated and maximum depth is stored in <i>maxDepth</i>.</p>
<p>• In lines 14-17, maxium of <i>maxDepth</i> and
<i>maxDiameter</i> is returned.</p>
<p><b>The above algorithm recursively runs on every node of the
tree . In each call, simple decisions and calculations are
computed. Thus, the algorithm runs in the linear time. That is</b>
<b><img src=
"../imgs/e1e8f96ac30c605620ed9604521c39710c57a012.png"></b>
<b>.</b></p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-9E">
                <a href="#problem-9E">9E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p>Consider a connected and undirected graph G= (V, E).</p>
<p>The algorithm to compute a path in G that traverses each edge in
E exactly once in each direction in O(V+E) time is shown below:</p>
<p>For solving given problem we will use a modified
Depth-First-Search algorithm.</p>
<p>• Every edge is marked the first and second time it is traversed
with unique marks for each traversal.</p>
<p>• If edges traversed twice then it may not be taken again.</p>
<p>This algorithm should ensure that all edges all explored, and
that each edge is taken in both directions.</p>
<p>• To ensure that all edges are explored, the algorithm must
ensure that unexplored edges are always taken before edges that are
explored once.</p>
<p>• To ensure that edges are taken in each direction, we simply
backtrack every time the depth-first search reaches a dead-end.</p>
<p>• The search keeps backtracking until a new unexplored edge is
found.</p>
<p>This way, edges are only explored in the reverse direction
during the backtracking. This algorithm is based on depth
–first-search. Therefore the running time of this algorithm is O(V+
E).</p>
</div>
</body>
</html>

            </div>     
        </div> 
        
            </div>    
            <div class="info">
                Chegg Rip, Introduction to Algorithms, 3rd Edition. [RipVer 0.1]
            <a href="../index.html">
                (index)
            </a>
            </div>
            <a class="return-float-btn" href="../index.html">
                <span class="arrow-left icon"/>    
            </a>
        </body>
        </html>
        