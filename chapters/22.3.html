<!doctype html>
        <html lang="en">
        <head>
          <meta charset="utf-8">
          <title>Chapter 22.3</title>
          <link rel="stylesheet" href="../style.css">
          
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script>
    window.onload=function(){
      setTimeout(function(){
        if(screen.width<680){
          var wrapper=document.getElementById('wrapper');
          var zoom=screen.width/680;
          wrapper.style.zoom = zoom;
          document.body.style.width=screen.width+'px';
        }
      });
    };
  </script>

        </head>
        <body>
            <div id="wrapper">
                
        <div class="problem">
            <div class="problem-title" id="problem-1E">
                <a href="#problem-1E">1E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p>Consider the following four types of edges produced by the
depth-first search on a graph<img src=
"../imgs/5672f6e111ce86b3ddeefa437947ad630f9e892d.png">.</p>
<p>• Tree edges.</p>
<p>• Forward edges.</p>
<p>• Back edges.</p>
<p>• Cross edges.</p>
</div>
<hr>
<div class="answer">
<p>Now, consider a <img src=
"../imgs/fdf4fa7b73986c78ad9cf761ac0afea7e273bfa7.png">chart with
column and row labels WHITE, GRAY and BLACK label for a depth-first
search of a <b>directed graph.</b></p>
<table border="1" style="border-collapse:collapse;">
<tr>
<td></td>
<td>
<p><b>WHITE</b></p>
</td>
<td>
<p><b>GRAY</b></p>
</td>
<td>
<p><b>BLACK</b></p>
</td>
</tr>
<tr>
<td>
<p><b>WHITE</b></p>
</td>
<td>
<p>Tree edges</p>
<p>Forward edges</p>
<p>Back edges</p>
<p>Cross edges</p>
</td>
<td>
<p>Cross edges</p>
<p>Back edges</p>
</td>
<td>
<p>Cross edges</p>
</td>
</tr>
<tr>
<td>
<p><b>GRAY</b></p>
</td>
<td>
<p>Forward edges</p>
<p>Tree edges</p>
</td>
<td>
<p>Tree edges</p>
<p>Back edges</p>
<p>Forward edges</p>
</td>
<td>
<p>Tree edges</p>
<p>Forward edges</p>
<p>Cross edges</p>
</td>
</tr>
<tr>
<td>
<p><b>BLACK</b></p>
</td>
<td>
<p><img src=
"../imgs/c0ece50fddeb27c6ad91a29cb5a8839f0bd7d8f5.png"></p>
</td>
<td>
<p>Back edges</p>
<p>Cross edges</p>
</td>
<td>
<p>Tree edges</p>
<p>Forward edges</p>
<p>Back edges</p>
<p>Cross edges</p>
</td>
</tr>
</table>
</div>
<hr>
<div class="answer">
<p>Now, consider a <img src=
"../imgs/fdf4fa7b73986c78ad9cf761ac0afea7e273bfa7.png">chart with
column and row labels WHITE, GRAY and BLACK label with depth-first
search of an <b>undirected graph.</b></p>
<table border="1" style="border-collapse:collapse;">
<tr>
<td></td>
<td>
<p><b>WHITE</b></p>
</td>
<td>
<p><b>GRAY</b></p>
</td>
<td>
<p><b>BLACK</b></p>
</td>
</tr>
<tr>
<td>
<p><b>WHITE</b></p>
</td>
<td>
<p>Tree edges</p>
<p>Back edges</p>
</td>
<td>
<p>Tree edges</p>
<p>Back edges</p>
</td>
<td>
<p><img src=
"../imgs/c0ece50fddeb27c6ad91a29cb5a8839f0bd7d8f5.png"></p>
</td>
</tr>
<tr>
<td>
<p><b>GRAY</b></p>
</td>
<td>
<p>Tree edges</p>
<p>Back edges</p>
</td>
<td>
<p>Tree edges</p>
<p>Back edges</p>
</td>
<td>
<p>Tree edges</p>
<p>Back edges</p>
</td>
</tr>
<tr>
<td>
<p><b>BLACK</b></p>
</td>
<td>
<p><img src=
"../imgs/c0ece50fddeb27c6ad91a29cb5a8839f0bd7d8f5.png"></p>
</td>
<td>
<p>Tree edges</p>
<p>Back edges</p>
</td>
<td>
<p>Tree edges</p>
<p>Back edges</p>
</td>
</tr>
</table>
</div>
<hr>
<div class="answer">
<p>Now consider the edge, which is defined in both the above
tables:</p>
<p><b>Tree edges:</b></p>
<p>• The<img src=
"../imgs/5a8e5b7bae7409376091f135db4419d8ca553347.png">, is defined
as a tree edge if <img src=
"../imgs/22e5145793d8f84321bf4024a3efc21a89be6023.png">was
discovered by searching the<img src=
"../imgs/5a8e5b7bae7409376091f135db4419d8ca553347.png"></p>
<p>• WHITE color is used to indicate the tree edge.</p>
<p><b>Forward edges:</b></p>
<p>• It is defined as, “all those non-tree<img src=
"../imgs/5a8e5b7bae7409376091f135db4419d8ca553347.png">, which are
used to connect a vertex <img src=
"../imgs/e6db7907f47c792385f87cce217f933fd52f10b3.png">to a
descendent vertex <img src=
"../imgs/22e5145793d8f84321bf4024a3efc21a89be6023.png">in a given
depth-first tree”.</p>
<p>• BLACK color is used to indicate the forward edge.</p>
</div>
<hr>
<div class="answer">
<p><b>Back edges:</b></p>
<p>• It is defined as, “all those<img src=
"../imgs/5a8e5b7bae7409376091f135db4419d8ca553347.png">, which are
used to connect a vertex <img src=
"../imgs/e6db7907f47c792385f87cce217f933fd52f10b3.png">to an
ancestor vertex <img src=
"../imgs/22e5145793d8f84321bf4024a3efc21a89be6023.png">in a given
depth-first tree”.</p>
<p>• A self-loop considered here, which may exists in the directed
graph, to be back edges.</p>
<p>• GRAY color is used to indicate the tree edge.</p>
<p><b>Cross edges:</b></p>
<p>• All the other edges, except the above three defined edges are
known as Cross edges.</p>
<p>• The cross edges, in the same depth-first tree, can go between
the vertices as long as one vertex is not an ancestor of
another.</p>
<p>• BLACK color is used to indicate the forward edge.</p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-2E">
                <a href="#problem-2E">2E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<img src="../imgs/afefe1e13d04bbfead779999eaa42ad77ec7f87c.png">
<hr>
<img src="../imgs/2bd454a66fbecc06b099f072a1fffa8f1a3e76de.png">
<hr>
<img src="../imgs/df645a3f92293260664c47aba61ebb633f7ec74c.png">
<hr>
<img src="../imgs/e0df06c8e7d77114cc34ecf29cdeab86bdab6dc5.png">
<hr>
<img src="../imgs/a346ea5dde2d0d7cedc0b55cf66aecf131dce850.png">
<hr>
<img src="../imgs/2b0f74c682ecaa63b39c7fcf2b64f0dc8a621770.png">
<hr>
<img src="../imgs/0217c2198d4a8c23555d739209bf71cee911f5d4.png">
<hr>
<img src="../imgs/db6d9f8945700bbbba9bc2d29eee301f5b290d6a.png">
<hr>
<img src="../imgs/f02af25d191734e26d0c16400591f71b36f5cb92.png">
<hr>
<img src="../imgs/d18f056ae7742598867a29f409c15f4615ee0e21.png">
<hr>
<img src="../imgs/b027f644ddf858d3ddfa8846d57ae69d2959a40c.png">
<hr>
<img src="../imgs/77ce43d1f86a1c5a85873c20ef149295ca0ba6c6.png">
<hr>
<img src="../imgs/8b6eafac70c0f98fb11beef9cadd13f23b9dd17a.png">
<hr>
<img src="../imgs/091552fe7d4adfd8bc2d0c170532bd9765796d28.png">
<hr>
<img src="../imgs/9582b8fce09c9ca27f0fcce155890552a767c560.png">
<hr>
<img src="../imgs/54b29989186d19b6f3cbf9b87618c5230eb8d02b.png">
<hr>
<img src="../imgs/3e7c20dd04e755f902f75509308f61dab99e8996.png">
<hr>
<img src="../imgs/2ed38f56820d66f0eb50bf292705779d23e37666.png">
<hr>
<img src="../imgs/5c14ade73730e776acf4bb9db046e229930c3a2d.png">
<hr>
<img src="../imgs/08644dec67d0a80ef3f0173f0e325783e12b3936.png">
<hr>
<img src="../imgs/a6a3c9bc9cff368c491b19cf6175b0f4c0b8444f.png">
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-3E">
                <a href="#problem-3E">3E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p>Consider the following figure, which is the final result of the
depth first search (DFS) applied on a directed graph. Each node in
the given graph is time stamped with discovery times.</p>
<p><img src="../imgs/b61d4e9494020ab2fe0eac613ee3978733f835b6.png"
alt="Picture 1"></p>
<p><b>Figure (1)</b></p>
</div>
<hr>
<div class="answer">
<p>After applying DFS on a directed graph, the visiting and
finishing times of nodes can be represented using a parenthesis
structure. This is an important property of DFS. Parenthesis
theorem is used to represent the parenthesis structure of a
graph.</p>
<p>Now, apply the Theorem 22.7 (or Parenthesis theorem), on the
given graph, then the parenthesized structure of the above given
graph will be as follows.</p>
<p><img src="../imgs/3b16d49517925bc40690ee2f7b6fb090355c1a4f.png"
alt=
"D:\2015 FILES\MONTHS 2015\9 September\24.9.2015\Bibek 2254\Image\2.png"></p>
<p><b>Figure (2)</b></p>
</div>
<hr>
<div class="answer">
<p>• An interval in the figure represents the discovery time and
finishing time of a vertex. Parenthesis “(” represents the
discovery time of a vertex and parenthesis “)” represents finishing
time of a vertex.</p>
<p>• A rectangle represents the duration of discovering and
finishing times of the vertex.</p>
<p>• If two intervals are overlapped, that is one interval is
nested within other, the vertex corresponding to the smaller
interval is a descendent of the vertex corresponding to the
larger.</p>
</div>
<hr>
<div class="answer">
<p>The following is the redrawn graph of the given graph. The new
graph is drawn with forward and back edges. The edges drawn down
wards are the forward edges and edges drawn up words are back
edges:</p>
<p><img src="../imgs/6abe561eba570302dcfbbfdab8288344d974a52c.png"
alt="Picture 6"></p>
<p><b>Figure (2)</b></p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-4E">
                <a href="#problem-4E">4E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p><b>DFS (Depth First search)</b></p>
Depth first search means to search “deeper” in the graph. In this
search, we find out the vertex <i>V</i> which is discovered
recently and all the undiscovered edges from the vertex <i>V</i>.
Once we come across all the <i>V</i>’s edges that have been
discovered, we backtrack to find edges apart from the vertex from
which <i>V</i> was discovered. We continue this process until all
the vertices which are reachable from the source vertex are
discovered.</div>
<hr>
<div class="answer">
<p><b>DFS –VISIT:</b> Depth first search colors vertices to
indicate their state during the search. Each vertex is white in its
initial state, is grayed when <b>discovered</b> and blackened when
<b>finished,</b> that is when its adjacency list is completely
examined.</p>
<p><b>Algorithm:</b></p>
<p><b>DFS-VISIT (</b> <i>G,u</i> <b>)</b></p>
<p>1. time=time+1</p>
<p>//white vertex <i>u</i> has been discovered</p>
<p>2. <i>u.d</i>=time</p>
<p>3. <i>u</i>.color=GRAY</p>
<p>//explore edge <i>(u, v)</i></p>
<p>4. <b>for</b> each <i>v</i> <img src=
"../imgs/8477b9ba74b3d8054f97c6be761820c278169431.png">
<i>G</i>.adj.<i>u</i></p>
<p>5. <b>if</b> <i>v</i>.color==WHITE</p>
<p>6. <i>v</i>.<img src=
"../imgs/389395e136f15ee2cad6c4f681f1564cbec71895.png">=<i>u</i></p>
<p>7. DFS-VISIT (<i>G, u</i>)</p>
<p>// Blacken <i>u</i> when it is finished</p>
<p>8. <i>u</i>.color=BLACK</p>
<p>9. time=time+1</p>
<p>10. <i>u</i>.<i>f</i>=time</p>
<p>Here,</p>
<p><i>u.d</i> - discovery time of <i>u</i>.</p>
<p><i>u</i>.color - color of <i>u</i>.</p>
<p><i>v</i>.color - Color of <i>v</i>.</p>
<p><i>v</i>. <img src=
"../imgs/389395e136f15ee2cad6c4f681f1564cbec71895.png"> =
predecessor of <i>v</i>.</p>
<i>u.f</i> - finishing time of <i>u</i>.</div>
<hr>
<div class="answer">This algorithm used in DFS (<i>G</i>) (refer
textbook) and it finds 'discover time' and 'finishing time' in a
graph.</div>
<hr>
<div class="answer">
<p>So, according to the color state described above, if <b>line
3</b> (<i>u</i>.color=GRAY) is removed for storing of single bit
color, then there will be <b>infinite recursion</b>, as the white
color will be called each time; because which vertex is discovered
will not be known by that time. But if <b>the line number 8</b>
(<i>u</i>.color=BLACK) instead of <b>3</b> will be removed, and
then it is possible for a single bit of color storing <b>in DFS
visit</b>.</p>
<p>The main reason behind it, is that line 3 and 8 both are using
the same variable (<i>u</i>.color).</p>
<p>This algorithm is processed after the all vertices are painted
in white color in a graph. Then, one by one every vertex converts
into gray color and at last, all are in black color. This
represents that all vertices have now been visited using the
concept of DFS.</p>
<p>So, here, removing line 3 in the above algorithm does not result
in affecting the result because it does not affect the discover
time and the finish time. Similarly, line 8 in the algorithm also
does not have any affect. These colors are used only to analyze the
graph in a better way.</p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-5E">
                <a href="#problem-5E">5E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<img src="../imgs/fb24f9eae2449ae0d3e5f9e51f75380352a6d67d.png">
<hr>
<img src="../imgs/6518986ec33a67792073f67b9fa92f487eac1108.png">
<hr>
<img src="../imgs/81a84767b03d3163c5c244610b46f87aa0bafb30.png">
<hr>
<img src="../imgs/1f704c24e2565493317cea0126b7131f3adde87c.png">
<hr>
<img src="../imgs/beff5fe6b2f4a816c2e2b182ba30afb6f7d0b470.png">
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-6E">
                <a href="#problem-6E">6E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p>In an undirected graph, classifying an edge <img src=
"../imgs/85c45beb4db3fb7e903a2820ceb2be9cc51aa504.png"> as tree
edge or back edge according to <img src=
"../imgs/85c45beb4db3fb7e903a2820ceb2be9cc51aa504.png">or<img src=
"../imgs/f3423cc39eddabb107894758613b5d0215e3a99c.png"> encountered
first during the depth first search is equivalent to ordering of
the four types in classification scheme.</p>
<p>Depth First Search is an algorithm for a graph or tree for the
traversing and searching vertex in a graph by using backtracking
method.</p>
<p>In the undirected graph if depth first search is used for
traversal or searching of vertices then the edges of the graph are
classified in four categories and these are:</p>
<p>1. <b>Tree Edges</b>:</p>
<p>These are the edges<img src=
"../imgs/85c45beb4db3fb7e903a2820ceb2be9cc51aa504.png">in which v
is just uncovered or founded.</p>
<p>2. <b>Back Edge</b>:</p>
<p>Back edges are those which formed because of backtracking that
is an edge <img src=
"../imgs/85c45beb4db3fb7e903a2820ceb2be9cc51aa504.png">is
discovered as <img src=
"../imgs/f3423cc39eddabb107894758613b5d0215e3a99c.png"> that is
<i>v</i> is processed before <i>u</i> and is the parent of
<i>u.</i></p>
<p>3. <b>Forward edges</b>:</p>
<p>These are the edges<img src=
"../imgs/85c45beb4db3fb7e903a2820ceb2be9cc51aa504.png">of the graph
which a vertex <i>u</i> is connected with a descendent
<i>v</i>.</p>
<p>4. <b>Cross edges</b>:</p>
<p>These are the edges of the graph other than defined above. They
can be at the same level in the same depth first tree if one vertex
is not the parent of the other vertex or the edges in different
depth first trees.</p>
<p>Tree edges and back edges can be differentiated as for an edge
<img src="../imgs/85c45beb4db3fb7e903a2820ceb2be9cc51aa504.png"> it
is tree edge if <i>v</i> is just discovered through this edge while
back edges are those edges <img src=
"../imgs/85c45beb4db3fb7e903a2820ceb2be9cc51aa504.png">in which
<i>v</i> is the parent node of vertex <i>u</i>.</p>
<p>So the edges can be defined on the basis of encountering of
their nodes in the traversal of tree or graph that is if a node
encounters first then it is the parent of the node that encounter
after. Thus in the undirected graph classification of edges whether
they are tree edges or the back edges can be done by both the
methods in the same manner either by their encounter in depth first
tree or by ordering or classification scheme of edges.</p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-7E">
                <a href="#problem-7E">7E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p>The DFS (Depth first search) algorithm calls DFS-VISIT on each
vertex that is not visited yet. DFS-VISIT is called recursively to
visit adjacent vertices of a node. This recursion can be avoided by
using a stack.</p>
<p>Thus, consider the following stack operations:</p>
<p>• <img src=
"../imgs/ac542077ab84f50f29f15e260f68ec6a9b2b74fa.png">This
operation is used to pushes the node <img src=
"../imgs/22e5145793d8f84321bf4024a3efc21a89be6023.png">into the
stack<img src=
"../imgs/8ed84d56158ba1a7b99e8ba3ee5a22427ca2a5f3.png">.</p>
<p>• <img src=
"../imgs/1006891919a15272ffd1f3751141140def3252f8.png">: This
operation returns the top of the stack<img src=
"../imgs/8ed84d56158ba1a7b99e8ba3ee5a22427ca2a5f3.png">and also
removes the top element.</p>
<p>• <img src=
"../imgs/c1a1f59476f1efe2e08fc4ec14f28389214587ee.png">: This
operation returns the top of the stack without removing it.</p>
<p>• <img src=
"../imgs/5c1bd91993eeeeb46dd3ec77798c8e6ede50f660.png">: It returns
true if stack is empty, otherwise returns false.</p>
</div>
<hr>
<div class="answer">
<p><b>Consider the following DFS procedure, using a stack to
eliminate recursion:</b></p>
<p>DFS(<i>G</i>)</p>
<p>//for loop is used to iterate for all the vertices</p>
<p>1. <b>for</b> every vertex <img src=
"../imgs/68c4a8879be1afe2adb7cb74a1dab4c8e1cbf904.png"></p>
<p>//Set the color of the vertex white</p>
<p>2. <img src=
"../imgs/40fe07089ad28c0660a1b3ad8b763e102bc8af9a.png"></p>
<p>//Set the predecessor of the vertex <img src=
"../imgs/e6db7907f47c792385f87cce217f933fd52f10b3.png">to NIL</p>
<p>3. <img src=
"../imgs/7b1753b9fc2f4a3ef1c58f026eb394011330ae4b.png"></p>
<p>4. <i>time</i> = 0</p>
<p>5. <b>for</b> every vertex <img src=
"../imgs/68c4a8879be1afe2adb7cb74a1dab4c8e1cbf904.png"></p>
<p>6. <b>if</b> <i>u</i>.<i>color</i> = = WHITE</p>
<p>7. <img src=
"../imgs/ff8266f5a525bff74338131e28fceef83722e755.png"></p>
<p>//Define the procedure DFS</p>
<p><img src=
"../imgs/738ee6653baef4ede828e9984556afee20dde25a.png"></p>
<p>//Initially set the stack as empty</p>
<p>1. <img src=
"../imgs/dda7c96d76ad5ae8a49ed8786af2feb9246e167b.png"></p>
<p>// Now, set the color of the vertex GRAY</p>
<p>2. <img src=
"../imgs/b82b5bde9bbb536eaa9a9bb9b568005d408bf2f4.png"></p>
<p>//Perform the <img src=
"../imgs/f8177629833b87c467647db78317c0c2876b5bbd.png">operation to
push the vertex or node into the</p>
<p>// stack STK</p>
<p>3. <img src=
"../imgs/2c1e5d501d2833fc9d6ef46aa89af04469b196d7.png"></p>
<p>//While loop runs continuously, until the stack is empty</p>
<p>4. <b>while</b> <b><img src=
"../imgs/7b340c09af39e0d65fa190b1e7fb66c01c58423c.png"></b></p>
<p>5. <img src=
"../imgs/1051bfd5dce8e30a49dcb72bc036d399e381dca5.png"></p>
<p>6. <b>if</b> <i>t.color</i> = =WHITE</p>
<p>7. <i>time = time</i> + 1</p>
<p>8. <i>t</i>.<i>d</i> =<i>time</i></p>
<p>9. <i>t.color</i> = GRAY</p>
<p>// flag to check whether all adjacent vertices of <i>t</i> are
explored or not</p>
<p>10. <i>Flag</i> = 0</p>
<p>11. <b>for</b> <i>v</i><i><img src=
"../imgs/fcc42c0913278dd36fcbe2c2a035519905d5fe1e.png"></i></p>
<p>12. <b>if</b> <img src=
"../imgs/30b209b84e1e92f952931acae19ba5e464976f07.png"></p>
<p>13. <img src=
"../imgs/26ef1191205c98423743dc6c240042b8adb40beb.png"></p>
<p>14. <img src=
"../imgs/1ded068045fd06cc00260b10d6ebdb84a3c29b51.png"></p>
<p>15. <i>Flag</i>=1</p>
<p>// if all adjacent nodes are marked gray or black</p>
<p>16. <b>If</b> <i>Flag</i> = = 0</p>
<p>17. <i>t</i> = <img src=
"../imgs/4e9849f308a8a0add539249ca62f1db76ebc3b2f.png"></p>
<p>18. <i>t.color</i> = BLACK</p>
<p>19. <i>time = time</i> + 1</p>
<p>20<i>. t.f</i> = <i>time</i></p>
</div>
<hr>
<div class="answer">
<p><b>Explanation of the above DFS procedure:</b></p>
<p>• To eliminate recursion, stack is used and operations related
to stack are mentioned above.</p>
<p>• In line 1 of DFS, the <i>for</i> loop is used to initialize
the color and predecessor attributes of every node in a graph.</p>
<p>• To do so, the color of each node is set to white and
predecessor is set to NIL using line 2 and 3.</p>
<p>• In line 4, the global time variable is set to 0.</p>
<p>• In line 5-7, for each vertex that is white, <img src=
"../imgs/ff8266f5a525bff74338131e28fceef83722e755.png"> is
called</p>
<p>• In the line 1 of <img src=
"../imgs/8d0c79559cf21f95a505b4ce2f4c8b9bf3dca2e1.png">, an empty
stack is created. Here <i>p</i> is the starting vertex to
visit.</p>
<p>• In line 2, the color of the starting vertex(<i>p</i>) is
turned to grey and this vertex is pushed into the stack in line
3.</p>
<p>• After that, the <i>while</i> loop continues till there are
elements in a stack.</p>
<p>• Now the top of the stack(<i>t</i>) is retrieved. If this
vertex is not visited yet, then its discover time <i>t.d</i> is set
to <i>time</i> and its color is set to GRAY.</p>
<p>• In line 10, a Boolean value, <i>Flag</i>, is initialized to 0.
This is used to know whether all the adjacent vertices of <i>t</i>
are visited or not.</p>
<p>• In line 11-15, all the adjacent vertices of <i>t</i> that are
not discovered yet are pushed into the stack. If there exist such
vertices of <i>t</i>, <i>Flag</i> is updated as 1 at line 15.</p>
<p>• If there are no adjacent vertices of <i>t</i> that are to be
discovered, then Flag remains 0.</p>
<p>• In line 16-20, the <i>Flag</i> value is checked. If the
<i>Flag</i> is 0(it means , there are no further adjacent vertices
of <i>t</i> that are to be discovered), the color of <i>t</i> is
turned black and also it is removed from the stack. Also the
finished time is updated.</p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-8E">
                <a href="#problem-8E">8E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p><b>DFS (Depth First Search)</b></p>
<p>A directed graph here refers to a graph in which the direction
is specified. Depth first search means to search “deeper” in the
graph. In this search we find out the vertex <i>V</i> which is
discovered recently and all the undiscovered edges from the vertex
<i>V</i>. Once we come across all the <i>V</i>’s edges that have
been discovered, we backtrack to find edges apart from the vertex
from which <i>V</i> was discovered. We continue this process until
all the vertices which are reachable from the source vertex are
discovered.</p>
<p>Depth first search colors vertices to indicate their state
during the search. Each vertex is white in its initial state, is
grayed when <b>discovered</b> and blackened when <b>finished,</b>
that is when its adjacency list is completely examined.</p>
<p><img src=
"../imgs/3dd5756e768e744929f7eb3cb02b4eedb6030cd2.png"></p>
<p><img src=
"../imgs/ff31a03b0ec71fd704618f3b853b4d9a8cf85c2a.png"></p>
</div>
<hr>
<div class="answer">
<p><b>Adjacency list:</b> It is the list obtained by seeing the
vertex which is adjacent to the given vertex. Its adjacency list
representation is:</p>
<p><i>a</i> <img src=
"../imgs/300390ca0c0a1c92601b6cae3b48b51c451b47b9.png"><i>U</i>
<img src=
"../imgs/300390ca0c0a1c92601b6cae3b48b51c451b47b9.png"><i>V</i></p>
<p><i>U</i> <img src=
"../imgs/300390ca0c0a1c92601b6cae3b48b51c451b47b9.png">
<i>a</i></p>
<p><i>V</i> <img src=
"../imgs/300390ca0c0a1c92601b6cae3b48b51c451b47b9.png">none</p>
<p>The depth –first forest produced is:</p>
<p><img src="../imgs/afb0c0b41c277049c32f08c7bf20e12858de68fb.png"
alt="D:\Tiffs\New folder\2254-22.tif"></p>
</div>
<hr>
<div class="answer">
<p>Here, <i>a</i> is the source vertex. We start DFS search from
the source vertex <i>a</i> ,then we goes to vertex <i>U</i> which
has no other neighbor than <i>a</i> .Hence <i>U</i> is finished, we
next goes to vertex <i>V</i> ,after <i>V</i> is finished we
terminate.</p>
<table border="1" style="border-collapse:collapse;">
<tr>
<td>
<p>Vertices</p>
</td>
<td>
<p>Discovered time</p>
</td>
<td>
<p>Finishing time</p>
</td>
</tr>
<tr>
<td>
<p><i>a</i></p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>6</p>
</td>
</tr>
<tr>
<td>
<p><i>U</i></p>
</td>
<td>
<p>2</p>
</td>
<td>
<p>3</p>
</td>
</tr>
<tr>
<td>
<p><i>V</i></p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>5</p>
</td>
</tr>
</table>
<p>There is a path in <i>G</i> from to <i>U</i> and
<i>U</i>.<i>d</i>=2 &lt; <i>V.d</i> =4.Hence, vertex <i>U</i> is
not the successor of <i>V</i>, so <i>V</i> is not the descendant of
<i>U</i>. Hence, <b>the</b> <b>conjecture contradicts</b>.</p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-9E">
                <a href="#problem-9E">9E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p><b>DFS (Depth First search)</b></p>
<p>A directed graph here refers to a graph in which the direction
is specified. Depth first search means to search “deeper” in the
graph. In this search we find out the vertex <i>V</i> which is
discovered recently and all the undiscovered edges from the vertex
<i>V</i>. Once we come across all the <i>V</i>’s edges that have
been discovered, we backtrack to find edges apart from the vertex
from which <i>V</i> was discovered. We continue this process until
all the vertices which are reachable from the source vertex are
discovered.</p>
</div>
<hr>
<div class="answer">Depth first search colors vertices to indicate
their state during the search. Each vertex is white in its initial
state, is grayed when <b>discovered</b> and blackened when
<b>finished,</b> that is when its adjacency list is completely
examined.</div>
<hr>
<div class="answer">
<p>Here <i>u</i> and <i>v</i> are the two vertices in the directed
graph and we have to give an example such that there is a path from
<i>U</i> to <i>V</i> and any DFS results in <i>V.d&lt;=U.f.</i></p>
<p><i>V.d</i> = time of the discovery of the vertex <i>V</i>.</p>
<p><i>U</i>.<i>f</i> = time of the finishing of the vertex
<i>U</i>.</p>
<p><img src=
"../imgs/967a37f3e1059ffc86385d6ca379be340ab5e6f8.png"></p>
<p><img src=
"../imgs/bd36436678722697152e2c74d07a35925a3e85fe.png"></p>
</div>
<hr>
<div class="answer">
<p><b>Adjacency list:</b> It is the list obtained by seeing the
vertex which is adjacent to the given vertex. Its adjacency list
representation is:</p>
<p><i>a</i> <img src=
"../imgs/300390ca0c0a1c92601b6cae3b48b51c451b47b9.png"><i>U</i>
<img src=
"../imgs/300390ca0c0a1c92601b6cae3b48b51c451b47b9.png"><i>V</i></p>
<p><i>U</i> <img src=
"../imgs/300390ca0c0a1c92601b6cae3b48b51c451b47b9.png">
<i>a</i></p>
<p><i>V</i> <img src=
"../imgs/300390ca0c0a1c92601b6cae3b48b51c451b47b9.png">none</p>
</div>
<hr>
<div class="answer">
<p>Here <i>a</i> is the source vertex. We start DFS search from the
source vertex <i>a</i>, then we goes to vertex <i>U</i> which has
no other neighbor than <i>a</i>. Hence, <i>U</i> is finished we
next goes to vertex <i>V</i>, after <i>V</i> is finished we
terminate.</p>
<table border="1" style="border-collapse:collapse;">
<tr>
<td>
<p>Vertices</p>
</td>
<td>
<p>Discovered time</p>
</td>
<td>
<p>Finishing time</p>
</td>
</tr>
<tr>
<td>
<p><i>a</i></p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>6</p>
</td>
</tr>
<tr>
<td>
<p><i>U</i></p>
</td>
<td>
<p>2</p>
</td>
<td>
<p>3</p>
</td>
</tr>
<tr>
<td>
<p><i>V</i></p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>5</p>
</td>
</tr>
</table>
<p>Here, finishing time of <i>U</i> is 3 that is less than the
discovery time of <i>V</i> that is 4. Yet there is a path from
<i>U</i> to <i>V</i>. So, the <b>conjecture is not valid</b>.</p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-10E">
                <a href="#problem-10E">10E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p><b>Modified Depth first Search:</b></p>
<p>Consider the following modified depth-first search pseudo code
to display the all edges of a directed graph G, along with its edge
types.</p>
<p><b>DFS-show-edge (</b> <i><b>G</b></i> <b>)</b></p>
<p>1. <b>for</b> each vertex <img src=
"../imgs/68c4a8879be1afe2adb7cb74a1dab4c8e1cbf904.png"></p>
<p>// Set the initial color of the vertex as white.</p>
<p>2. <i>u.color</i> = WHITE</p>
<p>3. <i>u.π</i> = NIL</p>
<p>//set the global variable time to zero.</p>
<p>4. <i>time</i> = 0</p>
<p>// check for each vertex in graph.</p>
<p>5. <b>for</b> each vertex <img src=
"../imgs/68c4a8879be1afe2adb7cb74a1dab4c8e1cbf904.png"></p>
<p>// Check discovered vertex color is white, then visit it by
DFS-VISIT-show-edge</p>
<p>// (<i>G, u</i>)</p>
<p>6. <b>if</b> <i>u.color</i> == WHITE</p>
<p>// visit the discovered white vertex</p>
<p>7. DFS-VISIT-show-edge (<i>G, u</i>)</p>
<p><b>Explanation:</b></p>
<p>• DFS process starts with initializing the graph with the
vertices. From line one to three, color of all vertices is set to
white. And initially set the attributes <i>π</i> to nil.</p>
<p>• Now in the next line set the time counter to keep track
discover and finishing times of vertices.</p>
<p>• From the line five to line seven, if a vertex with white color
is found, then visit it with the help of DFS-VISIT-show-edge (<i>G,
u</i>).</p>
</div>
<hr>
<div class="answer">
<p><b>Modified Pseudocode for DFS-VISIT-show-edge (</b> <i><b>G,
u</b></i> <b>):</b> To visit the each discovered node in graph
which is of white color, the following pseudocode for
DFS-VISIT-show-edge (<i>G, u</i>) function is used. This function
called every time for discovered node with white color and <i>u</i>
will be the root.</p>
<p>DFS-VISIT-show-edge (<i>G, u</i>)</p>
<p>// increase time by 1 as the vertex u is visited</p>
<p>1. <i>time</i> = <i>time</i> + 1</p>
<p>// assign the discovery time to <i>u</i> vertex and record it as
new time</p>
<p>2. <i>u.d</i> = <i>time</i></p>
<p>// now paint the <i>u</i> vertex as Grey</p>
<p>3. <i>u.color</i> = GRAY</p>
<p>// now explore the edge (<i>u, v</i>) and visit recursively
v.</p>
<p>4. <b>for</b> each <i>v</i> belongs to
<i>G.Adj</i>[<i>u</i>]</p>
<p>// check color for <i>v</i>.</p>
<p>5. <b>if</b> <i>v.color</i> == WHITE</p>
<p>// if it is white, store the predecessor value</p>
<p>6. <i>v.π</i> = <i>u</i></p>
<p>// display edge (<i>u, v</i>) as tree edge</p>
<p><b>7.</b> print “(u, v)|tree edge “</p>
<p><b>//</b> visit the vertex <i>v</i>.</p>
<p>8. DFS-VISIT-Show-edge (<i>G, v</i>)</p>
<p>// if vertex color is Grey, display edge (<i>u, v</i>)| as back
edge</p>
<p>9. <b>elseif</b> <i>v.color</i> == GREY</p>
<p>10. print “(u, v)|back edge “</p>
<p>// in case of black color</p>
<p>11. <b>else</b></p>
<p>// <i>v.color</i> == BLACK</p>
<p>// check condition for forward edge and cross edge</p>
<p>12. <b>if</b> <i>u.d</i> &lt; <i>v.d</i></p>
<p>13. print “(u, v)|forward edge “</p>
<p>14. <b>else</b></p>
<p>15. print “(u, v)|cross edge”</p>
<p>// Set black color of <i>u</i> vertex if it is discovered or
finished</p>
<p>16. <i>u.color</i> = BLACK</p>
<p>17. <i>time</i> = <i>time</i> + 1</p>
<p>// now record the finishing time in <i>u.f</i></p>
<p>18. <i>u.f</i> = time</p>
<p><b>Explanation:</b></p>
<p>• DFS-VISIT-show-edge (<i>G, u</i>) is called when a vertex is
of white color is found.</p>
<p>• First line of this code is used to increment the <i>time</i>
counter. Line two is used to record the new <i>time</i> value
because the <i>u.d</i> discovery time and line three provide the
color grey.</p>
<p>• Fourth line used to explore the (u, v) edge. Check color for
<i>v</i> in line five.</p>
<p>• If vertex <i>v</i> is white, store the predecessor value in
line six.</p>
<p>• If the color of vertex is white that means it is a tree edge
as it is the node which is discovered and has to be included in
Tree. Now display the edge as tree edge in line seven.</p>
<p>• If vertex color is Grey, display edge (<i>u, v</i>)| as back
edge in line eight to ten, because the node is already visited
earlier and hence this edge is considered as back edge.</p>
<p>• From line nine to fifteen check for the color black and
display it as forward or cross edge accordingly. Finally set the
color Black if it is finished.</p>
<p>• Now increase the global counter and record the finishing time
in <i>u.f</i>.</p>
</div>
<hr>
<div class="answer">
<p><b>Modifications required for undirected graph:</b></p>
<p>For the undirected graph, the code form line fourth to line
eight in DFS-VISIT-show-edge (<i>G, u</i>) are required to be
modified.</p>
<p>Replace the line 4-8 with the following code:</p>
<p>// examine each vertex _ adjacent to u</p>
<p>1. <b>for</b> each <i>v</i> belongs to
<i>G.Adj</i>[<i>u</i>]</p>
<p>2. <b>if</b> <i>v.color</i> == WHITE</p>
<p>3. <i>v.π</i> = <i>u</i></p>
</div>
<hr>
<div class="answer">// display edge (<i>u, v</i>) as tree edge
<p>4. print “(u,v)|tree edge “</p>
<p>5. DFS-VISIT-directed-show-edge (<i>G, v</i>)</p>
<p>6. <b>else</b></p>
<p>// display edge (<i>u, v</i>) as back edge</p>
<p><b>7.</b> print “(u,v)|back edge “</p>
<p><b>Explanation:</b></p>
<p>• According to the theorem 22.10 theorem provided in the text
book, every edge in an undirected graph is either a back edge or
tree edge. Thus the code is modified as above.</p>
<p>• Tree edge will be displayed from line two to line four. And
back edge will be displayed in other case defined in line five to
line seven.</p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-11E">
                <a href="#problem-11E">11E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<img src="../imgs/7af236b5e8a9554c4b35c21b711845b8166d2c0b.png">
<hr>
<img src="../imgs/fd95e279c3310a6afe0bc9d03f3225530d89d82e.png">
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-12E">
                <a href="#problem-12E">12E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<img src="../imgs/5be5af772479e1a89cf53d829261f221777ec8be.png">
<hr>
<img src="../imgs/7a3fb14aedccfbd3e6b389b46b5ac848a6ba5b67.png">
<hr>
<img src="../imgs/293b156257ac82ae5c47b5527641cecacb699e8f.png">
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-13E">
                <a href="#problem-13E">13E</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<img src="../imgs/1c55c1027629c7378238c3af05ad6c096113b869.png">
<hr>
<img src="../imgs/26734935c77edfa78af951cf92e3a8ef12c9d5c5.png">
<hr>
<img src="../imgs/050c02b81b6e06b6f5807d9d03e27407b3c2381b.png">
</body>
</html>

            </div>     
        </div> 
        
            </div>    
            <div class="info">
                Chegg Rip, Introduction to Algorithms, 3rd Edition. [RipVer 0.1]
            <a href="../index.html">
                (index)
            </a>
            </div>
            <a class="return-float-btn" href="../index.html">
                <span class="arrow-left icon"/>    
            </a>
        </body>
        </html>
        