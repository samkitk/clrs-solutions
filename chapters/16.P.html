<!doctype html>
        <html lang="en">
        <head>
          <meta charset="utf-8">
          <title>Chapter 16.P</title>
          <link rel="stylesheet" href="../style.css">
          
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script>
    window.onload=function(){
      setTimeout(function(){
        if(screen.width<680){
          var wrapper=document.getElementById('wrapper');
          var zoom=screen.width/680;
          wrapper.style.zoom = zoom;
          document.body.style.width=screen.width+'px';
        }
      });
    };
  </script>

        </head>
        <body>
            <div id="wrapper">
                
        <div class="problem">
            <div class="problem-title" id="problem-1P">
                <a href="#problem-1P">1P</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<img src="../imgs/57a33b7a05b560576317aedfb887aecef4e94202.png">
<hr>
<img src="../imgs/6b97a51bd80ec905f66a7d434dc9b42d9b1fd5bc.png">
<hr>
<img src="../imgs/551f940caf627029f0868a9a56a00eb0dd3a03e8.png">
<hr>
<img src="../imgs/81f3e4096998a8641bcb089757469d0586d74f0d.png">
<hr>
<img src="../imgs/c63d0a98df37c5e30efe709a98e8cf33f8a8bcbf.png">
<hr>
<img src="../imgs/2933d56fa953ac883fac03ecb78010dfd8e14c80.png">
<hr>
<img src="../imgs/db0d94d06e6aa4ed0105ad35cdcb0392379a6f62.png">
<hr>
<img src="../imgs/8e7118aefdb8a8fb62dab5f24acafb4faada017a.png">
<hr>
<img src="../imgs/50e5f56b14f7ac5b575eda1d80e8d773ef680635.png">
<hr>
<img src="../imgs/d6104e32c542ee3463f5fd9204c0f92376ad0d63.png">
<hr>
<img src="../imgs/0c421f956f9cbab1bd5b15feb58c1c3de1ae5acd.png">
<hr>
<img src="../imgs/29cf2d8dd267228fd1352cd63e55da1a0bc413f4.png">
<hr>
<img src="../imgs/5b9c2457120f1dce41c99561db2e6dae5539328b.png">
<hr>
<img src="../imgs/afe6af0ad7c3d39198453e47d9d930fa09bd8512.png">
<hr>
<img src="../imgs/88abf3ee0f8d553301417bd76702e2e633764771.png">
<hr>
<img src="../imgs/f983c5a53b3dc43c5a2e618b91ea9c10e62c568e.png">
<hr>
<img src="../imgs/601e4d265d85ea4a9527ae19bb9672a72eec4654.png">
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-2P">
                <a href="#problem-2P">2P</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<img src="../imgs/262d7d210ece6f1a0e227480bc528999a026297c.png">
<hr>
<img src="../imgs/b2385a4d4320c115f45f14d9c7fc615862ac33ff.png">
<hr>
<img src="../imgs/185efb876725abe573166ec76356286a908fa36d.png">
<hr>
<img src="../imgs/2dbce4c6c3a743b5ef1e97840b12da62245d903f.png">
<hr>
<img src="../imgs/f1010947667c1ee45149052b9068dc993bd527d9.png">
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-3P">
                <a href="#problem-3P">3P</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p><i><b>a.</b></i></p>
<p>In the initial step, consider a set of columns which is not
linearly independent on<img src=
"../imgs/0f5bcd22bfa8bad40965a68367c0c51d581a4a6c.png">.</p>
<p>Then there are some subsets of the above considered set of
columns which are represented as S. The linear combination of the
subset is 0.</p>
<p>However, over <img src=
"../imgs/0f5bcd22bfa8bad40965a68367c0c51d581a4a6c.png">, there are
only two elements 1 and 0. The linear combination is the sum over
some of the subsets.</p>
<p>Consider this subset as<img src=
"../imgs/7590076f71015d55f74c3f34b371656642dbcf0f.png">, due to
linear dependence this set needs to be non-empty.</p>
<p>Now, assume some set of edges which are corresponded by the
columns.</p>
<p>Since, with each of the vertex 0 that belongs to<img src=
"../imgs/0f5bcd22bfa8bad40965a68367c0c51d581a4a6c.png">, the
columns had their total incidence, and it is even.</p>
<p>Therefore, if the graph taken under consideration is the
subgraph constructed by the edges then the degree of all the
vertices would be even.</p>
<p>Also, the set <img src=
"../imgs/7590076f71015d55f74c3f34b371656642dbcf0f.png"> is
non-empty, some of the components has an edge.</p>
<p>Restricted to any of the such component.</p>
<p>Since, the above component consists of even vertices and are
connected, it contains the Euler Circuit, and this is a cycle.</p>
<p>Now, assume that the graph that is being considered, consist of
some subset of edges which are the cycles.</p>
<p>Then, the vertex corresponding to these set of edges has even
degree, therefore, when the corresponding columns will be added,
the result would be the 0 column in <img src=
"../imgs/0f5bcd22bfa8bad40965a68367c0c51d581a4a6c.png">.</p>
<p>Since, the set of columns which are linearly independent, create
a matroid by the problem 16.4-2.</p>
<p>The set of edges which are acyclic in nature create the matroid
as well.</p>
<p>Hence, it is proved that the (E, I) of the part (a) is a
matroid.</p>
</div>
<hr>
<div class="answer">
<p><i><b>b.</b></i></p>
<p>The simplest way is to consider the edge of maximum weight that
does not complete the cycle.</p>
<p>Also, the other way is to apply the Krushkal’s algorithm on the
graph with negated edge weight.</p>
</div>
<hr>
<div class="answer">
<p><i><b>c.</b></i></p>
<p>Consider the graph of [3] with the following edges:</p>
<p>(1, 2), (2, 1), (2, 3), (3, 2), (3, 1)</p>
<p>In this <i>u</i> and <i>v</i> represents the edge from <i>u</i>
to <i>v</i>.</p>
<p><b>Consider the two set of edges which are acyclic in
nature:</b></p>
<p>A = (1, 2), (2, 3)</p>
<p>B = (3, 1), (3, 2), (2, 1)</p>
<p>Now, add an edge in B-A to A, this will create a cycle.</p>
<p><b>Thus, the property of exchange is violated here.</b></p>
</div>
<hr>
<div class="answer">
<p><i><b>d.</b></i></p>
<p>Assume that there is a graph which consist of a directed cycle
which consist of the edges correspond to the columns <i>S</i>.</p>
<p>Then, since the vertex in this cycle has as exactly as many
edges which are going out of this vertex as it is going into
it.</p>
<p>The corresponding rows of each vertex will add up to zero.</p>
<p>Since, the number of edges going out of the vertex is negative
and the incoming edges count is positive.</p>
<p>So, the result of summation of columns would be zero.</p>
<p><b>Therefore, they are not linearly independent.</b></p>
</div>
<hr>
<div class="answer">
<p><i><b>e.</b></i></p>
<p>The given correspondence is wrong.</p>
<p>Since, it is not that if there is no directed cycle in the graph
then the columns are linearly independent.</p>
<p><b>Therefore, there is no perfect correspondence between set of
the acyclic edges and the set of the independent columns.</b></p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-4P">
                <a href="#problem-4P">4P</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p><b>Scheduling variations</b></p>
<p>The algorithm that has deadlines and penalties in it, and
executes unit processes is given below:</p>
<p>1. Make a set of all the unit time tasks.</p>
<p>2. Define the deadlines of all the tasks.</p>
<p>3. Define the penalties of all the tasks. The penalty has been
applied when the task takes more than the completion time.</p>
<p>4. Now schedule the tasks in order of their monotonically
increasing deadline.</p>
<p>5. For any task, if the slot before the task’s deadline is
empty, then the task should be assigned.</p>
<p>6. If the slot is not empty, then the task is assigned to latest
unfilled slot.</p>
<p>Consider the following table:</p>
<p><img src=
"../imgs/89baef8a14b09eab3f5b34da23b7ce046eea5f74.png"></p>
<p>In the table given above, there are 7 tasks, these are
represented by <i>a</i><sub>i</sub>. The table also contains the
deadlines and penalties or weights. The deadlines are represented
by <i>d</i><sub>i</sub> and penalties are represented by
<i>p</i><sub>i</sub>.</p>
<p>By following the algorithm given above, the scheduling of all
the tasks is as follow:</p>
<p>First take that task which has maximum penalty. In this example
<i>a</i><sub>1</sub> has maximum penalty that is 35. Therefore put
task <i>a</i><sub>1</sub> in 4<sup>th</sup> slot because its
deadline is 4.</p>
<table border="1" style="border-collapse:collapse;">
<tr>
<td>
<p>1</p>
</td>
<td>
<p>2</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>5</p>
</td>
<td>
<p>6</p>
</td>
<td>
<p>7</p>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<p><i>a</i> <sub>1</sub></p>
</td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
<p>After putting <i>a</i><sub>1</sub> task, find task which has
2<sup>nd</sup> highest penalty. Task <i>a</i><sub>2</sub> has next
highest penalty therefore put <i>a</i><sub>2</sub> in
2<sup>nd</sup> slot because its deadline is 2.</p>
<table border="1" style="border-collapse:collapse;">
<tr>
<td>
<p>1</p>
</td>
<td>
<p>2</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>5</p>
</td>
<td>
<p>6</p>
</td>
<td>
<p>7</p>
</td>
</tr>
<tr>
<td></td>
<td>
<p><i>a</i> <sub>2</sub></p>
</td>
<td></td>
<td>
<p><i>a</i> <sub>1</sub></p>
</td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
<p>Now <i>a</i><sub>3</sub> task has next highest penalty and its
deadline is 4 therefore it must be completed before 4<sup>th</sup>
time slot. The time slot 4<sup>th</sup> is already occupied by the
<i>a</i><sub>4</sub> task but 3<sup>rd</sup> time slot is empty so
put <i>a</i><sub>3</sub> task at 3<sup>rd</sup> time slot.
Similarly put <i>a</i><sub>4</sub> task at 1<sup>st</sup> empty
slots because its deadline is 3.</p>
<table border="1" style="border-collapse:collapse;">
<tr>
<td>
<p>1</p>
</td>
<td>
<p>2</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>5</p>
</td>
<td>
<p>6</p>
</td>
<td>
<p>7</p>
</td>
</tr>
<tr>
<td>
<p><i>a</i> <sub>4</sub></p>
</td>
<td>
<p><i>a</i> <sub>2</sub></p>
</td>
<td>
<p><i>a</i> <sub>3</sub></p>
</td>
<td>
<p><i>a</i> <sub>1</sub></p>
</td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
<p>Then out of <i>a</i><sub>5</sub><i>, a</i><sub>6</sub> and
<i>a</i><sub>7</sub> tasks, <i>a</i><sub>5</sub> have highest
penalty but deadline of <i>a</i><sub>5</sub> is 1. Therefore move
to next highest penalty task that is <i>a</i><sub>6</sub>. The
deadline of <i>a</i><sub>6</sub> task is 4 which is also expired
therefore finally move to last task that is <i>a</i><sub>7</sub>
whose deadline is 6 therefore put the task <i>a</i><sub>7</sub> in
slot 6.</p>
<table border="1" style="border-collapse:collapse;">
<tr>
<td>
<p>1</p>
</td>
<td>
<p>2</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>5</p>
</td>
<td>
<p>6</p>
</td>
<td>
<p>7</p>
</td>
</tr>
<tr>
<td>
<p><i>a</i> <sub>4</sub></p>
</td>
<td>
<p><i>a</i> <sub>2</sub></p>
</td>
<td>
<p><i>a</i> <sub>3</sub></p>
</td>
<td>
<p><i>a</i> <sub>1</sub></p>
</td>
<td></td>
<td>
<p><i>a</i> <sub>7</sub></p>
</td>
<td></td>
</tr>
</table>
<p>Now, put task <i>a</i><sub>5</sub> and <i>a</i><sub>6</sub> on
5<sup>th</sup> and 7<sup>th</sup>empty slot in any fashion because
both are already expired.</p>
<table border="1" style="border-collapse:collapse;">
<tr>
<td>
<p>1</p>
</td>
<td>
<p>2</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>5</p>
</td>
<td>
<p>6</p>
</td>
<td>
<p>7</p>
</td>
</tr>
<tr>
<td>
<p><i>a</i> <sub>4</sub></p>
</td>
<td>
<p><i>a</i> <sub>2</sub></p>
</td>
<td>
<p><i>a</i> <sub>3</sub></p>
</td>
<td>
<p><i>a</i> <sub>1</sub></p>
</td>
<td>
<p><i>a</i> <sub>5</sub></p>
</td>
<td>
<p><i>a</i> <sub>7</sub></p>
</td>
<td>
<p><i>a</i> <sub>6</sub></p>
</td>
</tr>
</table>
<p>So, the order in which the tasks should be completed is as
follow:</p>
<p><i>a</i> <sub>4</sub> <i>, a</i> <sub>2</sub> <i>, a</i>
<sub>3</sub> <i>, a</i> <sub>1</sub> <i>, a</i> <sub>5</sub> <i>,
a</i> <sub>7</sub> and <i>a</i><sub>6</sub></p>
<p>Only task <i>a</i><sub>5</sub> and <i>a</i><sub>6</sub> are
completed after the deadline therefore total penalty is the sum of
penalty of these two tasks.</p>
<p><img src=
"../imgs/fe1254bf556a488530656e1af738d4563e1b641a.png"></p>
</div>
<hr>
<div class="answer">
<p><i><b>a.</b></i> The algorithm given above always provides an
optimal answer because the algorithm emphasis on the penalty of the
task. It means that the task which has highest penalty will be
considered first and put in the execution table before it is
expired like <i>a</i><sub>1</sub> task in above example. Then
consider the next highest penalty task. In this way, always tries
to complete the tasks which has maximum penalty before its
deadline. The order found above (<i>a</i><sub>4</sub><i>,
a</i><sub>2</sub><i>, a</i><sub>3</sub><i>, a</i><sub>1</sub><i>,
a</i><sub>5</sub><i>, a</i><sub>7</sub> and
<i>a</i><sub>6</sub><i>)</i> using above mentioned algorithm is one
of the optimal solutions which has minimum penalty 50 for that
example. The above example may have different execution order but
the penalty never become less than 50.</p>
<p>So, this algorithm will provides always optimal solution.</p>
</div>
<hr>
<div class="answer">
<p><i><b>b.</b></i> Consider the section 21.3 of the textbook,</p>
<p>A disjoint set of forest is the set of tree in which each node
points to its parent node. In disjoint set of tree, each tree has
its root node which acts as a representative for the tree.</p>
<p>The technique used in disjoint set of forest to increase the
efficiency is <b>union by rank</b>. In this technique attach root
of smaller tree to the root of bigger tree. The efficiency is
depending on the depth of tree. If both tree have same depth then
only it decrease the efficiency otherwise it always increase the
efficiency.</p>
<p>In the example given above, the algorithm divides the tasks into
two parts.</p>
<p>First part is comprised of tasks 2, 4, 1 and 3 and second part
has the tasks 7, 5 and 6.</p>
<p>These tasks can be shown in graphical form as:</p>
<p><img src="../imgs/cb6693c4d6c14192e749e4db1c7903c63903393d.png"
alt="F:\Tiffs\all files\Naveen\udit.tif"></p>
<p><img src="../imgs/d1ea994143b09d385f36f0f8cf4016b9ce2e71ec.png"
alt="F:\Tiffs\all files\Naveen\udit.tif"></p>
<p>After making the disjoint-set of the two graphs given above, the
final graph is as follow:</p>
<p><img src="../imgs/9acb85cff3180bfe5064f3a10832f009c8869496.png"
alt="F:\Tiffs\all files\Naveen\udit.tif"></p>
<p>The running time of the implementation of the algorithm given
above will be O(<i>n</i><sup>2</sup>). It is because whenever any
new process is entered in the slot, the comparison has been made
with all the tasks.</p>
<p>As there are <i>n</i> number of tasks and when the <i>n</i>
tasks are compared with all the <i>n</i> tasks, the running time
becomes O(<i>n</i><sup>2</sup>). It is because there is requirement
of two “for” loops for tracing the tasks and to compare the
tasks.</p>
</div>
</body>
</html>

            </div>     
        </div> 
        
        <div class="problem">
            <div class="problem-title" id="problem-5P">
                <a href="#problem-5P">5P</a>
            </div> 
            <div class="problem-content">
                <!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<div class="answer">
<p><b>Cache memory</b></p>
<p>It is a small but expensive memory that lies between CPU and
main memory. The main motive behind to add this memory is to reduce
the data access time.</p>
<p>Whenever CPU requests for any data, the data is first searched
in the cache memory. If it is found in the cache then data is
returned from cache which is called as <b>hit</b>. If data is not
found in the cache memory then that data is searched and returned
from the main memory. It is known as <b>miss</b>. Whenever a miss
occurred then that data is also updated in the cache memory, in
order to reduce number of miss.</p>
<p><b>Off-line caching:</b></p>
<p>In Offline caching, it is already knows the sequence of request
that is <i>n</i> and the size of cache that is <i>k.</i></p>
</div>
<hr>
<div class="answer">
<p><i><b>a.</b></i> The method CACHE-MANAGER is a procedure of
generic, which initializes a cache by calling INITIALIZE-CACHE.
After this, call of ACCESS is made with each data element.</p>
<p>The inputs are entered in a sequence <img src=
"../imgs/fdfc7738f235aa9605b2defaa1cb6cb295efc0d2.png"> of memory
requests and a cache size<img src=
"../imgs/f060034fc8928b6735a170720aa0266092bbd136.png">.</p>
<p>CACHE-MANAGER<img src=
"../imgs/53814bed66f67d05c23049c607cced8fbf94821a.png"></p>
<p>INITIALIZE-CACHE<img src=
"../imgs/53814bed66f67d05c23049c607cced8fbf94821a.png"></p>
<p><b>for</b> <img src=
"../imgs/e611ef16d42e474a5e33939c071fa01728eb379a.png"> <b>to</b>
<img src=
"../imgs/7abec6553c20f7ba1096b722aa0174557f3c1373.png"></p>
<p>ACCESS<img src=
"../imgs/fda0f90da282a220bc7edb8b342c364324955a2a.png"></p>
<p>CACHE–MANAGER’s running time depends on implementation of
ACCESS. Now implement the greedy strategy described in the
problem.</p>
<p>A straight forward way of implementing the greedy strategy is
that when processing request<img src=
"../imgs/89a23dae577ca944b97eb1a38e7fea03160dd8b8.png">, for each
of the at most <img src=
"../imgs/f060034fc8928b6735a170720aa0266092bbd136.png">elements are
there in the cache, scanning of requests <img src=
"../imgs/76137ce2e6b07ec3d04c173cd6a8c01e0412a54c.png"> is there to
find elements in the cache which has access and <img src=
"../imgs/89a23dae577ca944b97eb1a38e7fea03160dd8b8.png">is the next
access. After this, the element has been evicted.</p>
<p>As each scan takes <img src=
"../imgs/b638eb6574849d0182f3e44fd149191efab60cb1.png">time, each
request entails <img src=
"../imgs/660ae2bc8832fe5102bc06d7ef66fa331a3fe287.png">scans, and
there are <i>n</i> requests, the running time of this straight
forward approach is<img src=
"../imgs/f38d209420d5ab84a025a6226c4dba1c0744ab2d.png">.</p>
</div>
<hr>
<div class="answer">
<p><i><b>b.</b></i> In order to show that the optimal sub-structure
is exhibited by the offline caching, define <img src=
"../imgs/dfd8b1f53366f2cfe800f5faa5f61dbc45734e37.png"> sub problem
before the <img src=
"../imgs/37b9cbbb78db11af3550aa8142437d1aada0b261.png"><sup>th</sup>
request as an content of cache. In sub-problem <img src=
"../imgs/dfd8b1f53366f2cfe800f5faa5f61dbc45734e37.png"><img src=
"../imgs/9004886286af59169980925a50e052a8a63d2909.png">is a subset
(having maximum of <i>k</i> elements) of input data elements.</p>
<p>The solution of sub-problem<img src=
"../imgs/dfd8b1f53366f2cfe800f5faa5f61dbc45734e37.png">is the
sequence of decisions states that which elements removed out from
the cache at each request of<img src=
"../imgs/0a1e02932ee27e0e8ad276c15f4ada4634b09626.png">;</p>
<p>The <i>optimal solution</i> of sub-problem<img src=
"../imgs/dfd8b1f53366f2cfe800f5faa5f61dbc45734e37.png">is the
solution which has minimum number of cache miss. No other solution
of sub-problem<img src=
"../imgs/dfd8b1f53366f2cfe800f5faa5f61dbc45734e37.png">can have
less number of cache miss than optimal solution.</p>
<p>Suppose <img src=
"../imgs/eba2ab067b168a07951abedb78996e61fc86ecb0.png">is an
optimal solution of sub-problem <img src=
"../imgs/dfd8b1f53366f2cfe800f5faa5f61dbc45734e37.png">and<img src=
"../imgs/7146275d5fcfa8d46292daca56af417f89b682aa.png">is a
sub-solution of<img src=
"../imgs/eba2ab067b168a07951abedb78996e61fc86ecb0.png">for
requests<img src=
"../imgs/4e2ec54338c6d759bbeeed14255c1639227e9ece.png">.</p>
<p>The content of cache remains same, if cache hit at the
<i>i</i><sup>th</sup> request. If cache miss at the
<i>i</i><sup>th</sup> request means requested data not found in
cache, then content of cache will change to <img src=
"../imgs/9e513b337259275b644636d06db0c3fdf0caf355.png"> by the
<i>i</i><sup>th</sup> request.</p>
<p>If <img src=
"../imgs/7146275d5fcfa8d46292daca56af417f89b682aa.png">is not an
optimal solution to<img src=
"../imgs/f0fbf52769966c14f06569607363f9701a0cbfb4.png">, then there
must be another solution<img src=
"../imgs/716554af9974f7106e9afe6633fc734f8a2fb92d.png"> for
problem<img src=
"../imgs/f0fbf52769966c14f06569607363f9701a0cbfb4.png">that has
less number of cache misses as compared to<img src=
"../imgs/7146275d5fcfa8d46292daca56af417f89b682aa.png">.</p>
<p>As it already state that <img src=
"../imgs/7146275d5fcfa8d46292daca56af417f89b682aa.png">is a
sub-solution of<img src=
"../imgs/eba2ab067b168a07951abedb78996e61fc86ecb0.png">therefore
<img src="../imgs/716554af9974f7106e9afe6633fc734f8a2fb92d.png">is
also a sub-solution of<img src=
"../imgs/eba2ab067b168a07951abedb78996e61fc86ecb0.png">. When
<img src="../imgs/716554af9974f7106e9afe6633fc734f8a2fb92d.png">
sub-solution combine with<img src=
"../imgs/eba2ab067b168a07951abedb78996e61fc86ecb0.png">at the
<img src=
"../imgs/37b9cbbb78db11af3550aa8142437d1aada0b261.png"><sup>th</sup>
request, then the resultant solution obtained by combination can
have less number of cache misses than<img src=
"../imgs/eba2ab067b168a07951abedb78996e61fc86ecb0.png">. This leads
to the contradiction of assumption that <img src=
"../imgs/eba2ab067b168a07951abedb78996e61fc86ecb0.png">provides
optimal solution to<img src=
"../imgs/dfd8b1f53366f2cfe800f5faa5f61dbc45734e37.png"> means
having less number of cache miss.</p>
<p>Assume that the <img src=
"../imgs/37b9cbbb78db11af3550aa8142437d1aada0b261.png"><sup>th</sup>
request is responsible for a cache miss.</p>
<p>Consider<img src=
"../imgs/8c0cdf7c6b21c0b43674ecfe713329566fd4c157.png">be the set
which contain all the cache states that can be accessed by
<img src="../imgs/9004886286af59169980925a50e052a8a63d2909.png">using
single decision manager of the cache.</p>
<p>The set <img src=
"../imgs/8c0cdf7c6b21c0b43674ecfe713329566fd4c157.png">have
<img src=
"../imgs/03d8da8b74b5cb84200b7503490d31834490ea1e.png">states:
<img src="../imgs/f060034fc8928b6735a170720aa0266092bbd136.png">of
them came from evicting one by one different elements of the cache
and one state came when no element is evicted.</p>
<p>For example,</p>
<p>If a cache <img src=
"../imgs/2abcbb7ac0cd4121d1a2d5405a291875cb58f265.png"> and the
requested data element is<img src=
"../imgs/185f86fa85520c28f2145166076f2a415e64ded0.png">, then a
miss occur. The set <i>P</i><sub>c</sub> contains all the 4 sets
which are as follow:</p>
<p><img src=
"../imgs/f44caa4bc0ab4aa2f27dfd688dc94237072502f3.png"></p>
<p>Consider<img src=
"../imgs/3ef017b3254818a3996728ac578b54ca300c747b.png">shows the
minimum number of cache misses for problem<img src=
"../imgs/dfd8b1f53366f2cfe800f5faa5f61dbc45734e37.png">. The
recurrence state for <img src=
"../imgs/3ef017b3254818a3996728ac578b54ca300c747b.png">is as
follow:</p>
<p><img src=
"../imgs/5fffaaab8cca4778b2a7e9ed405f845de3e22b57.png"></p>
<p>Hence, the problem always exhibits the optimal structure.</p>
</div>
<hr>
<div class="answer">
<p><i><b>c.</b></i> Greedy choice property is taken into
consideration for the proof of the furthest-in-future strategy.
According to this, this strategy always gives an optimal
solution.</p>
<p>Greedy choice property makes use of the optimal-substructure
property to prove that the furthest-in-future always produces
minimum number of cache misses.</p>
<p>Use various term in this part like sub-problem, solution and
optimal solution which is already define in previous part. Suppose
<img src="../imgs/fce6736f721b35c37b57d803ce5af184a2d18cce.png">is
defined as a solution state of the cache for solution <img src=
"../imgs/f9860816b2b75089f3a476b2ff059ea0189155a7.png">just before
the <img src=
"../imgs/37b9cbbb78db11af3550aa8142437d1aada0b261.png"><sup>th</sup>
request.</p>
<p>The theorem given below is the key:</p>
<p>Greedy-choice Property:</p>
<p>Consider<img src=
"../imgs/f9860816b2b75089f3a476b2ff059ea0189155a7.png">is an
optimal solution of <img src=
"../imgs/dfd8b1f53366f2cfe800f5faa5f61dbc45734e37.png">problem
and<img src=
"../imgs/62c55eb099ce9afae8e4cd9c69d82b4e42c201e5.png">is the
element in<img src=
"../imgs/97bcc2c5cd11e12a6ebf0263117f7bf8e6319a84.png">. At time of
<img src=
"../imgs/37b9cbbb78db11af3550aa8142437d1aada0b261.png"><sup>th</sup>
request, next access is furthest access in the future, at
time<img src=
"../imgs/18ac17158f24881a871af9d55a76083b78a5228a.png">.</p>
<p>Then, define another solution <img src=
"../imgs/808753fc331986fe1359cf4f68bf4f74cc8de9ce.png">of
problem<img src=
"../imgs/dfd8b1f53366f2cfe800f5faa5f61dbc45734e37.png">which has
following properties:</p>
<p><b>1.</b> On the <img src=
"../imgs/37b9cbbb78db11af3550aa8142437d1aada0b261.png"><sup>th</sup>
request, <img src=
"../imgs/808753fc331986fe1359cf4f68bf4f74cc8de9ce.png">
evicts<img src=
"../imgs/62c55eb099ce9afae8e4cd9c69d82b4e42c201e5.png">.</p>
<p><b>2.</b> For<img src=
"../imgs/29cbe483844cac897bf5f88d1ead5d35ee480107.png">, the
caches<img src=
"../imgs/e438d916f4aa264bbb7df814d35f069c7439853f.png">and<img src=
"../imgs/5266fb36f83d0fd7856e5a81bfa5a1a78182be96.png">has a
difference of at most one element.</p>
<p>If difference is there, then <img src=
"../imgs/f4f9b78ccb41d2288df30bb56c67d451672915ab.png">element will
be ion<img src=
"../imgs/e438d916f4aa264bbb7df814d35f069c7439853f.png">and is not
in<img src=
"../imgs/5266fb36f83d0fd7856e5a81bfa5a1a78182be96.png">.</p>
<p>Equivalently, if <img src=
"../imgs/e438d916f4aa264bbb7df814d35f069c7439853f.png">and
<img src="../imgs/5266fb36f83d0fd7856e5a81bfa5a1a78182be96.png">differ,
this can be written as<img src=
"../imgs/b9b874194bd13bc9665d426768d92a7865b405c1.png">
and<img src="../imgs/1029f56c965277cd33d0576f206f5b8d57b65042.png">,
where <img src=
"../imgs/14a23dd9e24b077db176c0c7bdcd542796dfa5c3.png">is a
size<img src=
"../imgs/bd7632ca16a2cb82d999c31e435ba4de52980184.png"> set and
<img src="../imgs/57b67c5a493fe54f72750eca8a0aa3f8b849d60d.png">is
some data element.</p>
<p><b>3.</b> For requests<img src=
"../imgs/ddc69af578da2b8253d1df273df6eb3e1333f6fe.png">, if
<img src="../imgs/f9860816b2b75089f3a476b2ff059ea0189155a7.png">has
a cache hit, then <img src=
"../imgs/808753fc331986fe1359cf4f68bf4f74cc8de9ce.png"> has a cache
hit.</p>
<p><b>4.</b> <img src=
"../imgs/2bb4865e2a13ced695779e13cd332282098870fa.png">for<img src=
"../imgs/06be676620c2e69c8a7ea6bc88a9b97268a13381.png">.</p>
<p><b>5.</b> For requests<img src=
"../imgs/00d58c50b208c8a2c590c7d80f62e3bb46b00d86.png">, missed
cache produced by <img src=
"../imgs/808753fc331986fe1359cf4f68bf4f74cc8de9ce.png"> is at most
the number of cache misses produced by<img src=
"../imgs/f9860816b2b75089f3a476b2ff059ea0189155a7.png">.</p>
<p>The above theorem and the optimal-substructure property proved
in part (<i><b>b</b></i>) imply that furthest-in-future always
produces the less numbers of cache misses.</p>
</div>
</body>
</html>

            </div>     
        </div> 
        
            </div>    
            <div class="info">
                Chegg Rip, Introduction to Algorithms, 3rd Edition. [RipVer 0.1]
            <a href="../index.html">
                (index)
            </a>
            </div>
            <a class="return-float-btn" href="../index.html">
                <span class="arrow-left icon"/>    
            </a>
        </body>
        </html>
        